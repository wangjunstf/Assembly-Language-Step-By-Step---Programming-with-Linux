# 第 6 章 有地儿，有工具 与工作息息相关的 Linux 操作系统和工具

DOS 被创建为更像某个强大的操作系统(即 Unix)的简化版本。Unix系统是 AT&T 研究实验室在 20 世纪 60 年代 和 70 年代开发的。当时，IBM 个人电脑已经出现，Unix 只允许在硕大的而安贵的大型机上。个人电脑没有原始的计算能力来运行 Unix。

DOS 下的Turbo Pascal 是第一个真正成功的，能够为程序员提供交互式开发环境(Interactive Development Environment，IDE)的商业产品。



## 6.2 Linux 和 终端

### 6.2.1 Linux 控制台

默认情况下，终端仿真程序使用 PC 键盘和显示器进行输入输出。它连接到一个与定义设备，可提供与 Linux 系统本省的通信。



终端程序只是一个程序，可以在 Linux 机器上安装各种不同类型的终端程序，每个终端程序可以在同一时间允许多个实例。但是，只有一个 Linux 控制台，我指的是名为 dev/console 的设备，它传送命令到 Linux 系统，并返回系统的响应。默认情况下，当启动的时候，终端仿真程序连接到 dev/console。如果愿意，可以使用 Linux 的终端仿真程序通过网络连接到其他设备



### 6.2.3 三个标准的 Unix 文件

人们将计算机描述为移动数据的机器，这是一种不错的看法。

理解 Unix 的一个根本设计原则：一切都是文件。

文件是数据所采用的路径的**端点**。当将数据写入一个端点时，你在沿着一条路径发送数据到一个端点。当从文件中读取数据时，你在从一个端点接收数据。数据在文件之间采用的路径可能完全位于一台计算机内部，或者位于某种类型的网络计算机之间。数据可以沿着路径处理或修改，或者它只是从一个端点移动到另一个端点，未做任何修改，无论怎样均可。

”一切都是文件“不只适用于磁盘上的数据集合。键盘是一个文件：它是一个生成数据并将其发送到某个地方的端点。显示器是一个文件：它是一个从某处接收数据并将其放在一个你可以看到的地方的端点。

下表为 Unix 定义的三个标准文件。当程序正在运行期间，这些文件对程序一直是打开的。

| 文件            | c 标识符 | 文件描述符 | 默认值 |
| --------------- | -------- | ---------- | ------ |
| Standard Input  | stdin    | 0          | 键盘   |
| Standard Output | stdout   | 1          | 显示器 |
| Standard Error  | stderr   | 2          | 显示器 |



在底层，操作系统通过文件描述符来知道一个文件。在某一程序内打开一个现有文件或者创建一个新文件时，Linux 会返回一个针对该文件的文件描述符。为了操作该文件，需要调用操作系统，向它传递你想处理的文件的描述符。

`mov ebx, 1			; 指定文件描述符1:标准输出`

 

### 6.2.4 I/O 重定向

`>` 和`<`是重定向操作符

`2>` 重定向标准输出到某些文件

`<` 它能够使原本来自键盘的标准输入重定向为来自另一个文件



如果将 `>` 换为 `>>`，就是将某些形式的输入追加到文件末尾



### 6.2.5 简易文本过滤器

NASM 汇编编译器本身就是一个过滤器：它读如满是汇编语言代码的源文件，对其进行处理，然后写出一个全是目标代码和符号信息的二进制文件。

程序可以通过将某些消息写到标准错误文件来发布文本状态和错误信息到终端显示仿真程序，所有这些都发生在它正在工作，标准输出文件正忙着将程序输出到磁盘期间。



### 6.2.6 使用转义序列进行终端控制

VT 终端观察其正在显示的数据流，并挑出具有单独释义的转义字符序列。例如：某个转义序列被解释为一个命令，用来实现清屏操作；另一个转义序列被解释为一个命令，用来在距离屏幕顶部 5 行，距离屏幕左边距 30 个字符的位置显示下一个字符。有几十个这种可识别的转义序列，它们让当时相对原始的文本终端能够向用户显示出格式整齐的文本，一次显示满满一屏。



Konsole 关键警惕一个通常情况下并不显示的特殊字符:ESC, 与之对应的 ASCII 码为 27，或 01Bh。当 Konsole 在其显示的文本流中看到一个 ESC ，它会非常仔细地查看后面几个字符。如果 ESC 字符后面的前三个字符是[2j，那么 Konsole 确认它为一个转义序列，该序列命令执行清屏操作，如果后面的字符是[11H，那么该序列命令将光标移动到显示器左上角的 home 位置。



毫不夸张地讲，有几十个不同的转义序列，它们都代表一些操作命令。如四处移动光标，改变字符的前景色和背景色，切换字体或字符编码，擦除线条或者部分线条或者整个屏幕的一部分，等等。通过向标准输出发出精心设计的转义字符序列，终端窗口中运行的程序能够完全控制整个显示器中的显示。

整个实现过程并不像听起来那么简单。在图形用户界面(GUI)应用时代到来之前，Unix 正是通过发送转义序列到终端(或终端仿真程序)来实现编程显示的。



### 6.2.7 为什么不用汇编语言编写 GUI 应用程序呢

使用汇编语言开发 GUI 应用程序是非常困难的，而且收效甚微。在能够使用汇编语言编写第一个 GUI 项目之前，你必须了解它的“所有”工作原理，并且为了迎接这一挑战，有很多的“所有”。

如果真心希望为某种 Linux 桌面管理器编写基于汇编语言的 GUI 应用程序，可以通过如下步骤接近这一目标：

1. 采用一种强大的本地编码高级语言(如Pascal，C或者C++)研究 Linux 编程。在这里，中级语言系统(如Python或者 Perl)基本不会对你有太多帮助。
2. 精通那种语言。研究它产生的代码，具体的做法是：将其加载到调试器，或者编译成汇编语言源代码并研究产生的汇编源代码文件。
3. 学习如何编写和连接汇编语言函数到你所选择的高级语言所编写的程序中。
4. 研究底层的窗口机制。对于 Linux 而言，这将是 X Window 技术，关于它已经有很多非常好的书籍。我最喜欢的一本书是The joy of X，作者是Niall Mansfield
5. 仔细研究一个特定的桌面环境和部件细节，如GNOME,KDE, xfce或者其他环境。(有很多中环境，而且其中一些被设计为轻量级，相对来说比较简单，如Xfce和windowLab)做到这一点的最佳办法就是用你所选择的高级语言为它编写应用程序，然后再研究汇编语言编译器产生的代码
6. 最后，通过模仿编译器生成的内容，尝试构建你自己的汇编代码。

## 6.3 使用 Linux Make

makefile的工作是：指定需要用程序的哪些部分来构建程序的其他部分。



### 6.3.1 依赖条件

生成文件(makefile)的内容制定了构建哪些文件需要哪些其他文件，以及需要采取哪些步骤来实现。Make 使用程序查看生成文件中的规则(依赖条件)并调用任何编译器，汇编编译器和它认为构建最终可执行文件或者库文件所需的其他实用程序。

```makefile
eatsyscall: eatsyscall.o
	ld -m elf_i386 -o eatsyscall eatsyscall.o


eatsyscall.o: eatsyscall.asm
	nasm -f elf -g -F DWARF eatsyscall.asm -o eatsyscall.o
```



### 6.3.2 文件何时最新

Make 可以判断目标文件是否为最新，如果为最新则没必要重新生成，节省了不必要的时间。

例如如下makefile

```makefile
eatsyscall: eatsyscall.o
```



Make 实用程序知道，可执行文件eatsyscall 依赖于目标代码文件eatsyscall.o，如果没有eatsyscall.o将无法生成eatsyscall，它还知道两个文件的最后更改时间，因此，如果可执行文件eatsyscall比eatsyscall.o，它便推断出对于eatsyscall.o所做的任何更改都已反映在eatsyscall中。（可以完全肯定，因为产生eatsyscall的唯一方式是通过处理eatsyscall.o）



### 6.3.3 依赖链

当一个单独的生成文件包含依赖链之后，Make 机制的真正价值才开始显现。即使在最简单的生成生成文件中，也会有某些依赖条件又依赖其他条件的情况。例如：

为了得到eatsyscall，首先需要的到eatsyscall.o，而为了得到，还需得到eatsyscall.asm

用一个makefile文件，可以自动编译得到所有需要的依赖条件，最终得到eatsyscall

```makefile
eatsyscall: eatsyscall.o
	ld -m elf_i386 -o eatsyscall eatsyscall.o

eatsyscall.o: eatsyscall.asm
	nasm -f elf -g -F DWARF eatsyscall.asm -o eatsyscall.o
```



## 6.4 Insight 调试器

Insight 与 KDbg，DDD 以及其他 Gdb 前端产品不同。Insight 实际上是 Gdb 的一部分，并且提供 Gdb 操作的另外一种(用于图形化桌面如 GNOME, KDE, xfce 以及所有的其余的桌面系统上使用的)窗口视图。

