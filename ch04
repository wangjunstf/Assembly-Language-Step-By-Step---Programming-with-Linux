# 第 4 章 位置 位置 位置 寄存器、内存寻址以及了解数据存储位置

## 4.1 内存模式的乐趣

在 32 位 Linux 下编程基本上只限于一种内存模式，一旦对内存寻址深入理解之后，你将会非常喜欢它。

* 最古老的内存模式叫**实模式平面模型**（real mode flat model），它完全僵化，但是相对简单。

* 年纪较大的（现在已经退休了的）内存模式叫**实模式段模型**（real mode segmented model）,这可能是编程语言里学到的最令人讨厌的东西。DOS 编程的最高境界会用到这种实模式段模型，其结果是使程序员们备受折磨。

* 最新的内存模式叫**保护模式平面模型**（protected mode flat model）,它是很多现代操作系统（如windows200/XP/Vista 和 Linux）背后的内存模型。

保护模式平面模型只能用于IA-32 体系结构的 386 及更新的 CPU 中。8086、8088 和 80286不支持。

*实模式平面模型非常像保护模式平面模型的缩影*。 



### 4.1.1 16位将带来 64 k 存储空间

8080 拥有一个 8 位的 CPU（即寄存器的位数），这意味着它一次能够处理八位的信息，然而它却拥有 16 根地址线。CPU 的位数——它的通用寄存器应该包含多少个位，它非常重要。在我看来，衡量  CPU 效率的最重要的标准是它一次操作能够调集多少根地址线

16 根地址线可以寻址 64k 字节，从二进制角度看，可以从0计数到65535。（口语中的“64K” 就是 65536的简称）

。意味着65536个单独的内存位置中任意一个都拥有唯一一个从 0 到 65535 之间的地址。

8080的内存寻址方案非常简单：把一个 16 位地址放到地址线上，然后取出存放在那个位置处的 8 位值。注意：**内存系统中的地址线的根数和存放在每个位置上的数据的位数之间没有必要的关系。**8080在每个位置存放8位二进制数，但是它也能够在每个位置存放 16 位或者 32 位数据，并前仍然使用 16 根内存地址线。



8080 主要使用的操作系统是 CP/M-80。CP/M-80出现在安装内存的顶部，有时为了便于包含在 ROM 中，但更主要的是为了让路，从而允许临时程序拥有一致的内存起点，临时程序被加载到内存中，只有需要的时候才运行。当CP/M-80 从磁盘读如一个程序并运行时，它将程序加载到距离内存底部256个字节的地址为0100H的地方。内存的前 256 **个字节叫程序段前缀**（Program Segment Prefix，简称为PSP），里面包含着各种零碎消息和一个用于程序磁盘输入输出的通用内存缓冲区。

当英特尔创建它的第一个 16 位 CPU——8086时，它想让人们更加容易地将较老的CM/M-80 软件从8080 翻译到 8086——这个过程叫移植。要想做这件事，一种方法是确保 16 位寻址系统（例如8080中的寻址系统）仍能够工作。尽管 8086能够寻址的范围是8080的16倍（16*64KB=1MB）,英特尔将 8086创建为可让程序只占用那 1M 内存里的 64K 字段，并前完全在它里面运行，就好像是小型的 8080 内存系统一样。下图是8080内存模式。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-05%20%E4%B8%8B%E5%8D%8812.36.35.png" alt="截屏2021-06-05 下午12.36.35" style="zoom: 67%;" />



这是通过使用段寄存器（segment register）来完成的，从根本上来讲，它们是位于 CPU 寄存器内部的内存指针，指向内存中事情开始的位置，这里所说的“事情”，可能是数据存储，也可能是代码执行或其他内容。

在8086内存的1M字节内，一个从8080世界移植过来的程序即将开始运行，如图4-2.

考虑名为CS的寄存器——它代表代码段（Code segment），它是指向8086的1M字节内存中的某一位置的指针。这个指针作为 64k 内存区域的起始点，在这个区域中，一个快速转换的 CP/M-80 程序能流畅地运行。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-05%20%E4%B8%8B%E5%8D%883.16.35.png" alt="截屏2021-06-05 下午3.16.35" style="zoom:50%;" />




短期内来看，这是一个非常明智的考虑，同时，从长期来看，这也是一种非常糟糕的设想。两年之内，许多 CP/M-80程序被转换成了 8086 程序。但是，当程序员们企图从头开始创建全新的，与 8080 从未谋面且不需要段模型的程序时，问题变得严重。段模型控制着 8086 的体系结构。一些一次需要大于 64KB内存的程序不得不使用64KB的内存块，通过切换进入和离开段寄存器的值来实现在这些内存块之间的切换。

这是一场噩梦，没有好的理由要学习它。



### 4.1.2 兆字节的本质

当运行在分段实模式下时，x86 CPU 最多能使用1MB 的可直接寻址内存。这个内存也叫实模式内存（real mode memory）。

1MB内存包含 1048576 字节，地址从00000H到0FFFFFH。

这就是 1M 字节内存：由包含 20 根电线的地址总线所连接的，计算机内部的一些内存芯片组合。通过向那 20 根地址线提供 20 位地址来标示 1MB 中的一个字节。



### 4.1.3 向后兼容和虚拟 86 模式

现代的x86 CPU（例如：奔腾）能够在比这更大的内存范围内进行寻址。对于 8086 和 8088 CPU而言，计算机真正拥有 20 根地址线和1兆内存。386 及其之后的英特尔 CPU 能够寻址4兆内存，而不必把它分成更小的段。当 32 位 CPU工作在保护模式实模型下时，一个段是4GB——所以大多数情况下，一个内存段足够。

然而，很多使用分段技术编写的DOS软件仍然随处可见，我们必须对其加以处理。所以，为了与 8086 和 8088 之前的CPU相互兼容，较新的 CPU 被赋予一种权利，使其能够将自己限制在老式CPU 能够寻址和执行的范围。当一个奔腾级别的 CPU 需要运行为实模式段模型编写的软件时，它将采用一项简洁的技术，暂时把自己变成一个8086，这叫虚拟86模式（virtual-86 mode），他对DOS软件提供了非常好的向后兼容性。



### 4.1.4 16位眼罩

在实模式段模型里，X86 CPU 可以“看到”整整 1MB 的内存。也就是说，CPU 芯片能够将自己设置为只能使用32个地址引脚中的20个，进而向存储器系统传递 20 位的地址。对于实模式段模型，虽然这些 CPU 可以看到整整 1M 字节内存，但是它们被限制为只能使用 16 位眼罩来看那 1 M字节。

CPU 看到的实模式段模型下的内存很特殊。它被限制为以块的方式查看内存，这些块中的长度都不超过 65536 字节，也就是我们所说的“64KB”。利用这些块——也就是说，知道目前正在使用哪一块以及如何从一个块移动到另一个块——是实模式段模型编程所面临的真正挑战。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-05%20%E4%B8%8B%E5%8D%884.57.43.png" alt="截屏2021-06-05 下午4.57.43" style="zoom:50%;" />



## 4.2 段本质

段是一个内存区域，它从一个段落边界开始，并且扩展一定数量的字节。在实模式分段模型中，这个数量小于或者等于 64K（65536）。

现在来上一段古老的86家族琐事的课。段落(paragraph)是一个内存度量，等于 16 个字节大小，它是用于描述不同内存容量的众多技术术语之一。我们之前已经见过了其中一些，它们都是1个字节的偶数倍。请记住：字节是原子数据；松散的内存位更像是亚原子粒子，如果包含它们的一个字节（或更多字节）“缺席”，这些内存位就根本不存在。有些术语使用频率较其他的高，例如下表：

| 名称 | 十进制值 | 16 进制值 |
| ---- | -------- | --------- |
| 字节 | 1        | 01H       |
| 字   | 2        | 02H       |
| 双字 | 4        | 04H       |
| 四字 | 8        | 08H       |
| 十字 | 10       | 0AH       |
| 段落 | 16       | 10H       |
| 页   | 256      | 100H      |
| 段   | 65536    | 10000H    |

任何能被 16 整除的内存地址称为一个段落边界（paragraph boundary）。第一个段落边界是地址0；第二个是地址 10H；第三个是地址20H。任何一个段落边界都可以被认为是另一个段落边界的开始。

在实模式段模型中，一个程序可能只使用四五个段，但是这些段中的每一个可能开始于65536个段落边界之中的任何一个，当然，这些段落边界位于这1MB在实模式段模型中可用的内存里。

每一个段都有一个编号，这些编号从0开始，一直到64k-1，用十进制表示是 65535，用十六进制表示是 0FFFFH。因为一个段落可能开始于任一段落边界，所以把段开始的那个段落边界的编号叫做段的段地址。如图4-4，每个阴影都是一个段地址，没16个字节开始的一个段。最高段的段地址为0FFFFH，它距离实模式1MB内存的最顶部16个字节。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-05%20%E4%B8%8B%E5%8D%885.47.48.png" alt="截屏2021-06-05 下午5.47.48" style="zoom:50%;" />



总之，段可以开始于任意段地址。共有 65536个段地址均匀地分布在实模式下的满满 1MB 内存中，每两个段之间相隔 16 个字节。以其说段地址是一个强制，不如说它是一个许可；对于所有64K个可能的段地址而言，只有五六个在某一时段被真正用作段的开始。

关于段的理解，最重要的一点是，它最大可达 64K 字节，但不一定非要那么大，一个段可能只有一个字节长，或者 256个字节长， 或者21378个字节长，或者任意小于64K的字节长。



### 4.2.1 一个界限，而非一个位置

一种对段的错误的认识就是：段是某种类型的内存位置，一旦预留出来用于某些特定应用的，两侧都有墙壁保护内存区域。

这个观点完全不正确。在实模式下，段内的任何内容都不受保护，而且段并没有被预留出来供某些特定的寄存器或访问方式使用。段也可以重叠。

我的观念是这样的：段是内存中安装 CPU 的64KB 眼罩的位置。通过这个眼罩查看内存，能够看到从段地址开始，一直到眼罩组织你的沿途所有字节，一共64KB。



### 4.2.2 用两个 16 位寄存器构成 20 位地址

寄存能够做很多工作，但最重要的一项也许就是存放内存中某些重要位置的地址。8086 和 8088 有 20 个地址引脚，它们的 1M 字节内存（它是我们正在谈论的实模式分段内存）需要 20 位大小的地址。

无法把一个 20 位的地址放到一个 16 位的寄存器中。但可以把一个 20 位的地址放入两个 16位 的寄存器中。内存中的每个字节都假设位于某个段中。那么，一个字节的完整地址包含它所在段的地址，还有该字节距离那个段的起始位置的的字节数是它的偏移地址。两个地址都指定才能完整描述实模式下整整一兆内存中的任意个字节的地址。在书写时，段地址写在前面，偏移地址写在后面，两者用“:”隔开。x86编程公约规定，当用这种形式表示一个地址时，不用在这两个十六进制数的结尾加上字母H。

发生的意外情况是：所有位于实模式下的 1MB 内存中的存储位置不是只有一个地址。如下图所示，一个我们称之为“MyByte”的字节数据存放在内存中用黑色标示出来的位置

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-05%20%E4%B8%8B%E5%8D%886.28.41.png" alt="截屏2021-06-05 下午6.28.41" style="zoom:50%;" />



严格来说，它实际位于哪一个段只是一个习惯问题。

这很尴尬，但它是多年以来我们能够做到的最佳方式。



## 4.3 16位和32位寄存器

段地址可被看作实模式下的 64KB 眼罩的起始位置。通常情况下，你会移动眼罩以找到希望工作的位置，然后把眼罩留在一个地方，在它周围的 64K 限制以内的空间范围移动。

这正是寄存器在实模式段模型下汇编语言中的用法。在8088，8086和80286中，有 4 个专门设计用于存放段地址的段寄存器。386 及后来的处理器又多了两个，它们也可以在实模式下使用。

段寄存器拥有反应其一般功能的名字：CS，DS，SS，ES，FS和GS。FS和GS只出现在386及更高版本的 Intel x86 CPU中，但大小仍然是32位。

* CS（code segment）代表代码段。机器指令存放在代码段的某些偏移位置处。CS中包含当前执行指令的代码段的段地址。
* DS（date segment）代表数据段。变量和其他数据存放在数据段的某些偏移位置处。也会有很多个数据段，，但 CPU 一次只能使用一个，这是通过将该段的段地址放入寄存器DS来实现的。
* SS（stack segment）代表堆栈段。堆栈是 CPU 用来暂时存放数据和地址的一个非常重要的部件。堆栈也是一个段地址，这个地址存放在SS中。
* ES（extra segment）代表附加段寄存器。附加段寄存器是一个可用于指定内存中某一位置的备用段。
* FS和GS是ES的克隆。它们都是额外的段，没有特殊的工作或专长，它们只存在于386 及后来的x86 CPU 中。



### 4.3.1 通用寄存器 

x86 有很多通用寄存器，它们用来做汇编语言计算的其余工作，在很多其他事情（除了计算之外的），这些通用寄存器用来存放偏移地址，它必须与段地址成对出现。它们还经常用于存放算术运算值。

从386开始的较新的 32 位 x86 处理器之间最大，最明显的区别之一：通用寄存器的大小。像段寄存器一样，通用寄存器也是 CPU 芯片本省内部的存储位置；也像段寄存器一样，它们都拥有自己的名字。

通用寄存器真的是通才，但是有些寄存器只能完成某些特殊的功能。有些特殊功能只是在老式的 16 位 CPU 中才会受到限制。

在32位世界中，通用寄存器分为三个一般类：16位通用寄存器，32位扩展通用寄存器和8位的半寄存器。这三类并不代表三个完全不同的寄存器。16位和8位寄存器实际上是32位寄存器内部的一块区域的名字。

有 8 个 16 位通用寄存器：AX，BX，CX，DX，BP，SI，DI和SP。（SP 不如其他通用寄存器通用性强，但有时会用到）。

当 Intel 于1986年将其 x86 体系结构扩展为32位时，它把所有 8 个寄存器的大小增加了一倍，并且通过在原有的名字前面加上前缀 E 来对他们进行重新命名，形成了EAX，EBX，ECX，EDX，EBP，ESI，EDI和ESP。

虽然扩展了新寄存器，但老寄存器一点没丢。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-05%20%E4%B8%8B%E5%8D%889.14.24.png" alt="截屏2021-06-05 下午9.14.24" style="zoom:50%;" />





上图展示的 4 个寄存器都完全是 32 位大小。然而，在每个寄存器里，低 16 位都拥有自己的名字。例如，ESI的较低的 16 位可以用 SI 来进行引用。

32位通用寄存器的高 16 位没有自己的名字。



### 4.3.2 半寄存器

有 4 个通用寄存器（EAX，EBX，ECX和EDX），它们的低 16 位本身被分成了两个 8 位寄存器，所以我们不是拥有两个寄存器，而是拥有三个级别的寄存器。16 位寄存器AX，BX，CX和DX作为EAX，EBX，ECX和EDX的低16位而存在，而AX，BX，CX和DX又被分为 8 位的半寄存器，编译程序能够识别这两个“半寄存器”的特殊名字。

字母A，B，C和D仍然保留，但是，半寄存器不再使用X，而是用一个H（高半寄存器）和L（低半寄存器）来表示它。每个半寄存器的大小都是一个字节（8位）。因此，字节大小的半寄存器 AH 和 AL 构成了 16 位寄存器 AX。依次类推。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-05%20%E4%B8%8B%E5%8D%889.29.10.png" alt="截屏2021-06-05 下午9.29.10" style="zoom:50%;" />



### 4.3.3 指针指令寄存器

代码段（code segment）是一块存储机器指令的内存区域。程序执行的测试和步骤就包含在代码中。根据使用的编程模型，一个程序可能有多个代码段或者只有一个。当前代码段（current code segment）是指段地址当前正存放在代码段寄存器CS中的那段代码。在任意给定的时间里，当前正在执行的指令都出现在当前代码段中。在实模式段模型里，CS 中的值经常变化。在两个平面模型里，CS中的值（几乎）从来没有变化，当然，在保护模式下的所有段寄存器都“隶属于” 操作系统，一般应用程序不能修改它。

当执行程序时，CPU 使用 IP 来跟踪位于当前代码段中的位置。每执行一条指令后，IP 就递增一定数量的字节，这个字节刚好是执行的那条指令的大小，最终的结果是，IP 跳到了更远的地方，指向了下一条即将执行的指令的开始位置。指令有不同的大小，典型的大小是1到6个字节，（其中有些更神秘的指令的更神秘的形式可能更大些）。CPU 谨慎地将 IP 怎加正确数量的字节数，因此，它实际最终指向下一条指令的起始位置。

CS 和 IP 一起，保存下一条即将执行的指令的完整地址。

地址的本质取决于使用的 CPU，以及正在使用的针对该 CPU 的编程模型。在 8088，8086和80286中，IP的大小是 16 位的。在 386 及更高的 CPU 中IP（像除段寄存器之外的其他所有寄存器一样）增加到 32 位的规模，变成EIP。

在实模式段模型中，CS 和 IP 一起工作，带来了一个 20 位的地址，指向实模式内存中的 1048576 个字节之一。

在两种平面模型中，CS 由操作系统设置并且保持不变，IP完成你（程序员）必须处理的所有指令指向。在 16 位平面模型中（实模式平面模型），这意味着IP可以跟踪所有 64K 内存段内的指令执行。 32 位平面模型做的远远超过其一倍，32位可以代表 4294967296 个不同的内存地址。因此在 32 位平面模型（即，保护模式平面模型）中，IP可以追踪 4GB 内存范围内的指令执行。

 IP是唯一不能直接读出，也不能直接写入的寄存器。有一些技巧可以用来获取当前 IP 寄存器的值。



### 4.3.3 标志寄存器

在8086，8088和80286中，它的大小是16位，并且它的正式名称是FLAGS。在 386 及更高的 CPU 中，它的大小是32位，正式名称是EFLAGS。标志寄存器的大多数位都可以作为名为标志位的一位寄存器来使用，这些单个标志位都有一个名字，例如CF，DF，OF等，并且每一个在CPU 内部都有一个特殊的含义。



## 4.4 三种主要的汇编模型

### 4.4.1 实模式平面模型

在实模式平面模型下，程序和它处理的所有数据都必须位于一个 64 KB 大小的内存块中。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-07%20%E4%B8%8B%E5%8D%888.55.30.png" alt="截屏2021-06-07 下午8.55.30" style="zoom: 50%;" />



由于 16 位寄存器可以容纳从 0 到 65535 之间的任意值，所以它能够精确定位程序使用的 64 KB 空间中的任一字节。因此内存寻址寻址不必显式使用段寄存器。当然从 CPU 的角度来看，段寄存器仍然在发挥作用，它并没有消失，只是当你加载程序的时候，操作系统会根据自己的选择来设置它的值。



### 4.4.2 实模式段模型

在实模式段模型下，程序可以看到在实模式下 CPU 可用的整个 1MB 内存。它通过把 16 位的段地址和 16位的偏移地址结合在一起来做到这一点，但它们不是简单地组合在一起，可以把一个段地址乘以 16 来将其翻译成一个真正的 20 位内存地址。因此，段地址 0002H相当于内存地址 0020H，这是内存中第 32 个字节。



这种乘法不需要程序员来做，CPU 会在内部将段地址和偏移地址组合成一个完整的 20 位地址。你的工作是告诉 CPU 那个 20 位地址的两个不同组成部分。惯用的表示方法是在段寄存器和偏移寄存器之间用一个冒号隔开：

SS:SP

SS:BP

ES:DI

DS:SI

CS:BX

图4-9 通过一幅简图来勾勒实模式段模型。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-07%20%E4%B8%8B%E5%8D%889.18.10.png" alt="截屏2021-06-07 下午9.18.10" style="zoom:50%;" />



该图显示了两个代码段和两个数据段。在实践中，可以有任意合理数量的代码段和数据段。你可以在同一时间访问两个数据段，因为有两个段寄存器可以做这项工作：DS和ES（在386及更高版本的处理中，还有两个附加段寄存器：FS 和 GS）每个都可以指定一个数据段，并且可以通过使用机器指令将数据段从一个段移动到另一个段。但是你只有一个代码段寄存器：CS。CS总是指向当前的代码段，IP寄存器指向下一条即将执行的指令的地址。不能直接加载一个值到 CS 中来实现一个代码段到另一个代码段的改变。如果必要的话，名为跳转的机器指令可以实现到另一个代码段的改变。



任意一个单独的程序都只有一个堆栈段，它有堆栈段寄存器 SS 来指定。堆栈指针寄存器 SP 指向下一条堆栈操作即将发生的(相对于SS而言，方向刚好是颠倒的)内存地址。



必须记住，在实模式下，也许有几个操作系统(如果你使用的是 8086 或 8088，那将是整个操作系统)与你的程序一起存在于内存中，同时还有一些重要的系统数据表。你可能由于粗心使用段寄存器而破坏部分操作系统，这将导致操作系统崩溃，并导致你的程序与之一起崩溃。正是这一危险促使促使英特尔在它的80386 及 更新的 CPU 上建立新的属性来支持 “保护模式”。在保护模式下，应用程序(也就是你写的程序，与操作系统或设备驱动程序相对)不能破坏操作系统或其他通过多任务技术碰巧在内存中运行的应用程序。



### 4.4.3 保护模式平面模型

由于Windows的历史遗留问题，目前可以为 Linux 和 NT 之后的windows 编写保护模式汇编语言程序。

编写保护模式程序的最简单方法是创建控制台(console)应用程序，它是文本模式程序，运行在一个名为控制台的文本模式窗口下。例如windows的CMD，Linux 下的终端。

图 4-10 表示保护模式平面模型。你的程序看到的是一块地址从0一直到4G-1的内存。每个地址都是一个 32 位的量。所有通用寄存器的大小都是 32 位，因此一个通用寄存器可以指向整个 4GB 地址空间中的任何位置。指令指针寄存器的大小也是 32 位，所以 EIP 可以指向 4GB 内存空间内的任何地方的任何机器指令。



段寄存器仍然存在，但是它们以一种完全不同的方式工作。不是你不一定受它们愚弄，而是你已经不能受它们愚弄。现在，段寄存被认为是操作系统的一部分，在几乎所有情况下，你既不能直接读取它们，也不能直接修改它们。它们的新工作是定义你的 4 GB 内存空间出现在物理内存或者虚拟内存的什么地方。物理内存可能远大于 4GB，而且目前 4GB 的内存并不是特别贵。然而一个 32 位的寄存器只能表示 4294967296 个不同的位置，你的程序仅限操纵该区域的内存。在较大的内存系统中定义 4GB 区域的范围，这就是段寄存器的工作，而且操作系统让它们寸步不离其“防护衣”。

虚拟内存，它是一个系统，可以根据它将一个更大的内存空间“映射”到磁盘储存器中，因此即使你的计算机中只有 4GB 的物理内存，CPU也能够处理一个数以百万计字节，更大空间的“虚拟内存”。这也是由操作系统来处理的，而其处理方式对你编写的软件几乎完全透明。

当程序运行时，它将得到一个 4GB 的地址空间来施展手脚，任何一个 32 位寄存器完全依靠自己就可以访问这四十亿字节内存中的任一位置。这是一个过于简化的描述，对于普通的基于 Intel 处理器的台式电脑而言，并非所有的 4GB 内存都是你的程序可以支配，这些内存空间你不但不能使用，



比较一下实模式平面模型和保护模式平面模型。

* 区别：在实模式平面模型下，你的程序拥有操作系统交给它的整整 64KB 内存空间。在保护模式平面模型下，你将得到分配给自己的 4GB 内存中的一部分，而其他部分仍属于操作系统。
* 相似：通过(GP)寄存器本身可以指定整个内存地址空间中的任一内存位置，段寄存器是操作系统的工具，而不是(程序员)的工具

> 同样，在保护模式平面模型下，一个通用寄存器可一存放其 4GB 空间内的任意位置的地址，但是当真正读取或写入某些位置时，会被操作系统禁止并且触发运行时错误。

内存寻址和寄存器都是业务的关键。如果了解了它们，指令将是小事一桩。保护模式平面模型下编程的困难在于了解操作系统及其要求和限制。





## 4.5 保护模式下不再允许我们做的事情



### 4.5.1 内存映射系统

显卡包含一定数量的内存，这块内存“映射”到个人电脑的物理内存空间。换句话说，在访问显卡过程中并没有什么“魔术参与”。简单的将数据写到由段地址：偏移地址指定的，位于显卡包含的内存范围内的某一地址，就可以将一些内容显示在显示器上。

这种技术允许程序显示满满一屏文本，这些文本将一下子弹入我们的视野，没有任何文字从上到下有逐渐出现的感觉。即使是在早期那些拥有慢得令人难以置信的 CPU 芯片的机器上。内存缓冲区的组织非常简单：从地址0B00:0(或彩色显示器0B00:0)开始，是一个两字字节的数组。每个字的第一个字节是一个字符的ASCII 编码。例如，数字 41H是大写字母"A"的编码。第二个字节是一个文本属性：字形的颜色，字符单元格的背景颜色，或者下划线之类的特殊表示方法。



多了在多任务处理时不导致输出混乱，操作系统不得不通过精心制作的视频显示代码库来“管理”视频，依次地，这些代码库通过与内核一同位于内核空间的驱动程序访问显示硬件。驱动程序使得操作系统能够限制单个程序到屏幕的视频输出，以便任意数量的正在运行的程序可以同时显示其输出，而不必和所有其他程序的输出发生碰撞。



综上所述，有一种方法能够在用户内存中建立一个缓冲区，然后告诉Linux 把它当作显存来使用。这涉及到一些与 Linux 帧缓冲设备 dev/fb0，及函数mmap 和 ioctl 相关的忙乱工作，但是它不够简单和迅速。



在本书的后面，将会介绍一个控制台窗口和VT100终端控制序列演示一种颇受青睐的处理文本屏幕输出的Linux方法。



### 4.5.2 直接访问端口硬件

在 DOS 时代，个人电脑拥有由主板上单独的控制器芯片所控制的串行端口和并行端口。与计算机的所有其它组件一样，这些控制器芯片可被运行在DOS下的任意软件直接访问。

加上一些聪明才智，你可以让标准的计算机硬件做它并不真的打算做的事情。



同视频一样，多任务需求也要求操作系统管理对端口的访问，这可以通过驱动程序和代码库来访问，但是与视频不同，使用驱动程序作为端口处理的接口实际上比完全靠自己控制端口简单得多。



### 4.5.3 直接调用 BIOS

在 DOS 时代，有可能直接用软件直接调用BIOS例程，而没有任何限制。

保护模式预留出 BIOS 调用给操作系统，但是说实话，那个实话，即便是保护模式下的操作系统，也很少直接调用BIOS，几乎所有的低级硬件访问都是通过可安装的驱动程序来完成的。操作系统大多利用 BIOS 调用来确定诸如电源管理之类的事情的硬件配置信息。



作为一个安慰奖，Linux 提供了一个低级函数列表，可通过一个与 BIOS 调用非常相似的机制来进行调用，即使用软件中断 80H。

在本书的稍后部分，将讲解软件中断。



## 4.6 展望未来：64位 “长模式”

x86-64 体系结构定义了三个一般模式：实模式、保护模式和长模式。

IA-32：英特尔32位架构（英语：Intel Architecture, 32-bit，缩写为IA-32），常被称为i386、或x86，由英特尔公司于1985年推出的指令集架构。它是8086架构的延伸版本，可支持32位运算，首次应用在Intel 80386芯片中。

* 实模式

  是一种兼容模式，它使 CPU 能够运行旧的的实模式操作系统和软件，如 DOS 和 Windows 3.1。在实模式下，CPU 像 8086 或其他 x86 CPU 在实模式下一样工作，并且支持实模式平面模型和实模式段模型。

* 保护模式

  也是一种兼容模式，使得 CPU 在软件看来就像是一个 IA-32 CPU ，以便x86-64 处理器能够运行windows 2000/XP/Vista/7 和其它的 32 位操作系统(如Linux)，以及它们的 32 位驱动程序和应用程序。

* 长模式

  是实 64 位模式；在 CPU 长模式下，所有的寄存器都是 64 位宽，所有工作于 64 位的机器指令都是可用的。



左右在 IA-32 下可用的寄存器依然存在，并已经被扩大到 64 位宽。64位寄存器被以 R 开头进行重新命名。

例如 EAX 变成 RAX，EBX变成RBX。8个全新的 64 位通用寄存器R8到R15，还增加了 8 个 128位的SSE 寄存器(快速数学运算特性)， 



### 64 位内存：前景 VS 现在

64位 可以寻址 16 艾字节，艾字节是 2<sup>60</sup>个字节，等于十亿GB。

今天可以买到的x86-64 CPU能实现 48 位虚拟内存地址，但是只能实现 40 位物理内存地址。2<sup>40</sup>是1T字节。

64位长模式仍然是平面模型，它与 32 位平面模型的相似之处，远远超过了 32 位平面模型与愚昧的实模式段模型的相似之处。

