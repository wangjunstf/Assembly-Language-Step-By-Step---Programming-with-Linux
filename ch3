# 第 3 章 摘下面具 探索计算机的真正面目

一个基于Windows的COSMAC ELF模拟软件非，它能够接收和执行COSMAC程序：

https://billr.incolor.com/computer_simulators.htm



## 3.1 晶体管开关

晶体管是很小的硅晶体，它利用硅独特的电子属性来充当开关，有空理解那些独特的电子属性。

让我们把晶体管看作是一种类型的用电驱动的黑盒子，并用输入和输出这两个属于来描述它。



下图展示了一个晶体管开关（它是一个场效应晶体管，实际上它只是一种类型的晶体管，但确实我们当前计算机所使用的类型）当电压被加到管脚1时，电流在管脚2和管脚3之间流动。当电压被从管脚1中移除时，电流停止在管脚2和管脚3之间流动。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-04%20%E4%B8%8A%E5%8D%88111.png" alt="截屏2021-06-04 上午111" style="zoom: 33%;" />



在现实生活中，少数其他部件（最典型的是二极管和电容）也是必要的，它们可以使计算机存储器工作得更加稳定。

晶体管开关及其支持部件合在一起称为存储单元。



## 3.2 随机访问

某种古老的存储器，它们被放在某种电磁机器上，旋转磁鼓存储器发出一个圆形的，位于磁性传感器下方的比特集合。传感器下方每次通过一个比特，如果错过了想要的那个比特，就需要重新再扫描一次。它们以固定的顺序向我们展示比特，一次展示一个，你必须按照它的顺序来等待你需要的比特。

随机访问是这样工作的：在芯片内部，每一个比特都存放在它自己的存储单元中，每一个此类存储单元都有一个独一无二的编号，这个编号就是一个单元（一个比特）的地址。



每个芯片都有很多从它引出的管脚，称为地址管脚。每个管脚叫做一个数据管脚，如下图所示，这些地址管脚是传递二进制地址码的电引线。地址是一个只用0合1表示的二进制数字。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-04%20%E4%B8%8B%E5%8D%883.png" alt="截屏2021-06-04 下午3" style="zoom:50%;" />



RAM芯片内部专用电路将地址解码成芯片内部的大量存储单元中的一个选定的输入。对于任意应用到这个地址管脚的给定地址而言，只有一个选定的输入会被提高到5v，进而实现对那个内存单元的选择。

根据打算读取一个比特还是写入一个比特，数据管脚会在存储单元的输入或输出之间进行切换。

这些都是在芯片内部完成的。而在芯片外面呈现的效果是；一旦一个内存地址被应用到地址管脚上，数据管脚就会马上发生变化。



每次访问内存的时间很短，通常30纳秒，但计算机需要访问成百上千，数百万或数十亿计次存储器，积少成多，也会耗费很长时间。编程高手给出的建议：**只要能不介入内存，就不介入内存**（但会非常难）



## 3.3 字节，字，双字，四字

除了非常古怪和特殊类型（比如，比如某些职能食品加工机）的计算机外，没有计算机处理比1个字节还小的信息。事实上，当今大多数计算机一次处理双字（4字节或32位）的信息。自从2003年来，pc兼容机已经能够一次性处理4字（64位）的信息。



## 3.4 精致的芯片排成一行

下图是一个存储器系统，它把一个存储的字节分布在8个单独的RAM芯片上。每一个黑色矩形代表如图3-2所示的RAM芯片。这8个芯片每一个存放字节中的一位，而且采用同一地址。8个芯片的20根地址管脚被连在一起（并联）。当计算机 把一个存储器地址应用到这20根地址线时，地址同时出现在存储器系统的所有8个芯片的地址管脚上，在八位数据总线上同时传递8个比特的数据，每一个来自于其中一个芯片。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-04%20%E4%B8%8B%E5%8D%883.52.19.png" alt="截屏2021-06-04 下午3.52.19" style="zoom:50%;" />



这样简单的存储芯片已经不复存在，大多数存储器芯片在每一个地址不止存放一个比特的数据。每个地址存放1个，2个，3个，4个和8个比特数据的芯片相对普遍。如图3-3，每个地址存放8个比特。



计算机中每个字节的存储器都有它唯一的地址，即使是在一次处理2，4或8个字节信息的计算机中。

在32位和64位计算机中，每个字节都有它自己的地址，但是当一台32位计算机访问一个字节时，它实际一次读取从这个字节开始的4个字节，你可以使用剩余的3个字节，或者如果不需要，干脆忽略它们。

如图3-3，将每个黑色矩形与8个数据线相连，每次就能传输64比特信息。



如图3-3所示，这是1个8位存储系统，每个地址能访问1字节数据。



## 3.5 车间工厂和流水线

也许有些人会说，CPU是实际完成工作的部件，但这种观念过于单纯化了，很多实际的工作是在存储系统和我们称之为外设的设备中完成的，如显卡，USB和网络端口等。



## 3.6 对话内存

CPU芯片最重要的工作就是与计算机存储器系统进行通信。如图3-4所示，当CPU需要从内存中读如一个字节（一个字，双字，四字时），它把该字节的内存地址放到它的地址管脚上，编码成一个二进制数。几纳秒之后，所需的字节就出现存储器芯片的数据管脚上。CPU芯片也有数据管脚，它通过自己的数据管脚读取存储器芯片提交的字节。



这个过程可以反向进行，为了向内存中写入一个字，CPU首先把它想写入的存储器地址放到它的地址管脚上，几纳秒以后，CPU把它想写入的字节放到自己的数据管脚上，存储器芯片就乖乖地把这个字节的数据放到请求的地址中。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-08%20%E4%B8%8B%E5%8D%885.16.32.png" alt="截屏2021-06-08 下午5.16.32" style="zoom:50%;" />



## 3.7 驾驭数据总线

显卡，硬盘，USB和网络端口是个人电脑最常用外设。像CPU和存储器一样，它们都是靠电驱动的设备。大多数现代外设包含一到两个大芯片，也许包含一对支持大芯片的小芯片。这些外设都包含地址管脚和数据管脚。一些外设（尤其是图形卡）还拥有自己的存储器芯片，目前他们使用专用的CPU。（现代图形卡是一个拥有自主权的高性能计算机，尽管它只拥有一个特定而有限的使命）。

外设能够与CPU“谈话”，有时也相互通信。所有计算机中的外设都有通用的管脚。这些电线被称为数据总线，它们形成了一种类型的合用线，把CPU连接到计算机的所有其他部件上。一个复杂的电仲裁系统决定这些不同的设备能够在什么时间以什么顺序使用这根合用线来互相“交谈”，但是它经常以同样的方式发生：地址被放到总线上，后面跟着一些数据（一次多少数据取决于所设计的外设）。总线上发出一些特定的信号，用于指明该地址是代表存储器中的一个位置，还是绑定到地址线中的外设。为了和前面一直讨论的存储器地址区分开来，我们将外设地址称为I/O地址。

在大多数个人计算机中，数据总线是出现在扩展槽中的主要元素，而很多外设（尤其是图形卡）就是这些插入扩展槽中的印刷电路板。通过数据总线在扩展槽中的电路管脚实现的连接，外设可以与CPU和内存进行对话。

尽管扩展槽使用起来方便，但它们在计算机内部也会产生一些延迟。简单来说，外设只是计算机内部的主要电路板（主板）上的某个角落处的几个芯片。



## 3.8 车间工长的口袋

即寄存器。

CPU的即时工作过程在名为寄存器的临时存储容器中进行。

大多数外设也有寄存器，外设寄存器的使用范围比CPU寄存器的使用范围更小一些。



## 3.9 流水线

如果CPU是车间工长，那么外设就是流水线上的工人，数据总线就是流水线本身。

问题是：是谁告诉车间工长及其手下员工该做什么事情？是你。你应该怎么做到呢？你编写一个程序。程序从哪里来呢？它在存储器中，与很多存放在存储器中的数据一起。实际上，程序也是数据，它是我们所知的整个编程思想的核心。



## 3.10 遵循计划行事的盒子

正如字母表和数字代表对我们人类有意义的某些内容一样，代码集对CPU也意味着这些内容，这些代码被称为机器指令。并且它们的名字可以通过其实际内容来进行记忆。当 CPU 正在执行一个程序时，它从数据总线上取出一系列数字，每次取出一个。每个数字告诉 CPU 做某件事情。当执行完某条指令时，它取出下一条指令并执行。它继续执行到某些东西（程序中一条指令，或诸如复位按钮的之类的电信号）告诉它停下来。

例如，对于Intel的现代CPU通用的例子：8位二进制编码 01000000(40H)对于CPU来说，意味着一条命令：**向寄存器AX中的值加一，并将其和存回AX**。大多数机器指令不只占用一个字节，很多指令占用2个字节或4个字节。二进制代码1101011001110011 (0B6H 073H)构成另一条指令：把数值73H加载到寄存器DH中。而二进制编码 1111001110100100  (0F3H 0A4H)则能够引导CPU完成以下事情：**开始把由CX寄存器指定数量的字节从存放在DS和SI中的32位地址中取出来，并存入存放在SI和DI中的32位地址处，每移动一个字节，同时更新SI和DI中的地址，并将CX中的值减一，最后当CX中值变为0时，停止执行。**

Intel IA-32 :英特尔32位架构（英语：Intel Architecture, 32-bit，缩写为IA-32），常被称为i386、或x86，由英特尔公司于1985年推出的指令集架构。它是8086架构的延伸版本，可支持32位运算，首次应用在Intel 80386芯片中。

Intel IA-32所能理解的其余几百条指令的复杂性和功能大致在这两条指令之间。

**每一条指令一般情况下高速计算机执行一个较小且有限的任务。很多指令被按顺序提交给CPU，以引导其完成更复杂的任务。而写出这些指令序列实际上就是汇编语言编程。**



## 3.11 取址和执行

CPU 一执行完一条指令，就转到存储器，按顺序取出下一条指令。在CPU内部，有一个特殊的寄存器，名为指令指针寄存器，它包含下一条即将从内存中取出和执行的指令的地址。每当一条指令执行完毕后，这个指令指针都被更新为指向内存中的下一条指令。

所有这些都像时钟一样规规矩矩地指向。计算机有一个以电驱动的子系统，叫做时钟系统（system clock），它实际上是一个能够以非常精确的时间间隔发出方波脉冲的震荡器，CPU内部的很多极小的晶体管开关根据系统时钟产生的脉冲来协调它们的行为。

CPU的运行过程是这样的：取指和执行；取指和执行。CPU在指令指针寄存器的指引下在内存中行进。

**计算机程序是存储在内存中的二进制机器指令的列表。在内存中，它们与其他数据字节的列表没有任何区别，只是当被取出时，CPU对它们的解释有所不同。**



## 3.12 车间工长的内脏

大部分CPU内部的开关包含不只一个手柄。这些开关，称为门(gate)，它们根据逻辑规则进行工作。为了让某个开关通过门来实现“关闭”，也许需要两三个或更多个“打开”开关投掷同时到达某个特定的门。

这些门被用于在CPU内建造复杂的内部机制。



## 3.13 改变航向

计算机本质的第一个魅力是：内存中的一串二进制编码一步一步地高速计算机做哪些事情。第二个魅力是皇冠上的真正宝石：有一些机器指令能够改变机器指令被取出和执行的顺序。



## 3.14 是什么 vs 怎么做：体系结构和微体系结构

CPU 的灵魂被清楚地分为两个部分：CPU 做什么事情； CPU如何做这些事情。程序员从外面来看它：CPU做什么事情。设计计算机主板和其他包含Intel处理器硬件系统的电子工程师和系统设计人员需要知道其余内容，但是他们是极少数非常吃苦耐劳的一群人，他们知道自己是谁。



### 3.14.1 体系结构的演变

除了向指令集周期性地添加内容外，体系结构本身也在突飞猛进。这些飞跃的典型情况体现在CPU的“宽度”上。1986年，随着80386 CPU 的引入，Intel的16位体系结构扩展到了 32 位，并且添加了大量的指令和操作模式，CPU寄存器的宽度也怎加到原来的两倍。2003年，X86体系结构继续扩展，这次是到64位，而且又添加了很多新的指令，操作模式和扩展寄存器。



### 3.14.2 地下室里的秘密机制

由于涉及向后兼容问题，除非有非常好的理由，否则 CPU 的设计者们不会再添加新的指令或寄存器到体系结构中。有一些其他的更好的方法来改善 CPU 家族。这些方法最重要的是要提高处理器的吞吐量，它不仅仅是单纯地提高 CPU 时钟频率的问题。另一个是要降低电量消耗。

提高处理器的吞吐量意味着提高同一时间段内 CPU 执行的指令数目。很多神秘的技术与提高吞吐量有关，例如：预读取，L1高速缓存，L2高速缓存，分支预测，超管道和微操作熔合等。

总的来说， CPU 为了完成指令让它做的事情而依赖的所有电机制通称为 CPU 的微体系结构。



## 3.15 操作系统：角落办公室

实际上，我们早期的微机操作系统并不是很强大，也做不了太多事情。它们旋转磁盘，处理存储在磁盘驱动器中的数据，当需要时，将数据送回磁盘。它们接收来自键盘按键的敲击，然后把字符发送到显示器。另一种较少的情况是，它们能够把字符发送给打印机。这就是操作系统。

早期的操作系统，加载应用程序时，系统将会放到软驱中，因为内存空间有限。应用程序执行完比后，操作系统重新加载入内存，等待下一条命令。



### 3.15.1 BIOS：是软件，但并不软

IBM已经将处理键盘，显示器和磁盘驱动器的程序代码单独拿出来并烧制到一种特殊类型的，名为只读存储器（ROM）的存储器芯片上。一般的随机存储器在断电时内容就消失了。而ROM不管有没有电都会保持它的内容，这样成千上万条机器指令就不用从磁盘中加载了，因为它们总是位于一个焊在主板上的ROM芯片里。**ROM上软件称为基本输入输出系统（basic input output system），简写为BIOS，因为它能处理计算机的输入设备（例如键盘）和输出设备（例如显示器和打印机）**



### 3.15.2 多任务魔术

windows95 拥有一些以前PC世界中从未见过的内容：**抢先式多任务处理器(preemptive multitasking)**

windows95营造了一种令人相信的错觉：内存中的所有程序在同一时间内运行。这是通过每一个加载到内存中的程序赋予一个CPU时间片来完成的。程序在CPU上开始运行，它的若干条机器指令将会得到执行。运行一个程序时，经过一段时间之后（通常是几分之一秒），windows95 从第一个程序中“抢回” 对 CPU 的控制权，然后将其交给列表中第二个程序。如此循环。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-04%20%E4%B8%8B%E5%8D%8811.22.53.png" alt="截屏2021-06-04 下午11.22.53" style="zoom: 33%;" />



操作系统能够为列表中的每一个程序赋予一个优先级，以便有些程序能够比其他程序获取更多的执行时间。



### 3.15.3 内核提升

Linux 没有像 windows 95 一样精美饿图形用户界面，但是它能够处理多任务，而且内部具有更为强大的结构。Linux的核心是一个名为内核（kernel）的代码块，它充分利用了IA-32 保护模式的优点。Linux 内核与图形用户界面是完全分开的，它被保护起来以防被系统某处非正常工作的程序损坏。系统存储器或者被标示为内核空间（kernel space），或者标示为用户空间，运行在用户空间的任何内容都不能被写入（一般情况下也不能从内核空间读取）存放在内核空间的任何内容中。内核空间和用户空间之间的通信通过严格控制的系统调用来进行处理。

只有运行在内核空间的软件才能直接访问物理硬件（包括内存，显存，外设）。希望使用系统外设的程序只能通过内核模式设备驱动来实现访问。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-04%20%E4%B8%8B%E5%8D%8811.39.29.png" alt="截屏2021-06-04 下午11.39.29" style="zoom:67%;" />



### 3.15.4 内核爆炸

2000年初，拥有两个 CPU 插口的台式 PC 开始销售。通过使用“对称多处理(SMP)”机制，Window 2000/xp/7 和Linux都支持在一个单系统中使用多个 CPU。当所有处理器都一样时，处理器是“对称的”。当可以使用两个CPU时，操作系统在大多数情况下在一个 CPU 上运行自己的代码，而在另一个 CPU上运行用户模式应用程序。

随着技术的进步，出现了多核心 CPU，四核以上 CPU是可能的，但是，如何使用这样一笔令人为难的财富仍然需要更多的讨论。



### 3.15.5 计划

计算机是一个能够执行计划的盒子。

这个计划（即内存中的机器指令列表）就是汇编语言程序。本书的核心内容就是学会如何将这些机器指令正确地排列到内存中供CPU使用。

是时候开始近距离观察机器指令引导 CPU执行的操作的本质。如同计算中所有内容一样，操作大部分是在存储器中完成的，这些存储器包括主板上的常规内存，又包括那些记忆之王——CPU 寄存器。

