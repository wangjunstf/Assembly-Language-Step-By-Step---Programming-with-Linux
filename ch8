# 第 8 章 我们的崇高目标 创建能够工作的程序

## 8.1 汇编语言程序的基本框架

```asm
; 可执行程序明 : EATSYSCALL
; 版本 : 1.0
; 创建日期 : 2021-1-9
; 作者 : 王俊
; 描述 : 一个简单的 Linux 下的汇编应用程序，使用  NASM 2.13.02
;   演示了  Linux INT 80H  系统调用显示文本的用法
;
; 使用这些命令生成：
; nasm -f elf -g -F DWARF eatsyscall.asm -o syscall.o
; ld -m elf_i386 -o eatsyscall eatsyscall.o
;

SECTION .data                   ; 包含已初始化的数据的段


EatMsg: db "Eat at Joe's!",10
EatLen: equ $-EatMsg

SECTION .bss                    ; 包含未初始化的数据的段
SECTION .text		        ; 包含代码的段

global _start                   ; 连接器需要据此找到入口点！

_start:
	nop			    ; 这个无操作指令让 gdb 非常高兴
	mov eax,4		; 指定 sys_write 系统调用
	mov ebx,1 		; 指定文件描述符1：标准输出
	mov ecx, EatMsg	        ; 传递显示信息的偏移地址
	mov edx,EatLen 		; 传递显示信息的长度
	int 80H			; 进行系统调用来输出文本到标准输出
	
	mov eax,1 		; 指定 Exit 系统调用
	mov ebx,0		; 返回一个零代码
	int 80H			; 进行系统调用来终止代码
```



### 8.1.1 最开始的注释块

汇编语言编码的目的之一，是使用仅可能少的指令来完成某项工作。这并不意味着创建尽可能短的源代码文件。源文件的大小与编译后得到的可执行文件的大小毫无关系！放入文件的注释越多，当下次再捡起它的时候，你就越能更快地想起它的内部工作原理。我想你会发现，一个复杂的汇编语言程序的逻辑在你的脑海里的冷却速度快的惊人。



注释既不浪费时间，也不浪费空间。IBM 曾建议"每行代码一个注释"。这很好，并应被视为汇编语言工作最其码的组成内容。一个更好的(我在后面较为复杂的例子中所遵循的)习惯是在每一行代码的右侧使用一行短行注释，同时在共同完成某一单独任务的每个指令序列的开始位置添加注释块。

每一个程序的顶部应该是一个标准的注释块，其中包含一些重要的信息：

* 源代码文件的名称
* 可执行文件的名称
* 创建该文件的日期
* 最后一次修改该文件的日期
* 程序编写者的名字
* 用于创建它的汇编编译器的名称和版本
* 程序或者库文件所做事情的概要说明。需要多少空间你就用多少。它并不会影响可执行程序的大小和速度。
* 如果使用生成文件(你应该那么做)的话，还应该有一个来自于生成文件的，用于生产该文件的命令的副本

对于程序开头的注释块而言，挑战在于更新它，以使其反映项目的当前状态。



### 8.1.2 .data段

用 NASM 编写的运行在 Linux 下的普通用户空间程序分为三个段，这些段在程序中的排列顺序并不重要，但是根据习惯，.data 段在最上面，其次是 .bss段，最后是 .text段。

.data 段包含了已初始化的数据项的数据定义，已初始化数据在程序开始运行前就拥有了自己的值，这些值是可执行文件的一部分，当可执行文件被加载到内存中用于执行时，它们被加载到内存中。你不必非要将它们与其值一起加载，除了将程序作为一个整体而加载到内存中所需的机器周期之外，并不需要额外的时间来创建它们。

关于 .data 段，最重要的是，定义的初始化数据项越多，可执行文件就会越大，运行它的时候，也就需要更长的时间才能将它从磁盘里加载到内存中。



### 8.1.3 .bss 段

并不是所有数据项在程序开始运行之前都拥有值。例如，从磁盘文件读取数据时，当数据从磁盘中出来之后，需要有一个存放的地方。那样的缓冲区是在 .bss 段中定义的。你为缓冲区预留一定数量的字节，然后给缓冲区取一个名字，但是并不指明缓冲区中将要出现什么值。

.data 段中定义的数据项和 .bss 段中定义的数据项之间有一个重要的差别：.data 段中定义的数据项将会添加到可执行文件的大小上，而 .bss 段中定义的数据项则不会。我们可以在 .bss 段中定义一个 16000(或更多)字节的缓冲区，而可执行文件的大小几乎不变(除了大约 50 个字节用于描述以外)

Linux 加载程序把程序带入内存的方式使这成为可能。当生成可执行文件时，Linux 连接器向描述所有已定义符号的文件添加一些信息，包括用来命名数据项的符号。加载程序知道哪些数据项没有初始值，当把可执行文件从磁盘加载到内存时，它为这些数据项分配空间，而具有初始值的数据项则与其初始值一起读如。



### 8.1.4 .text 段

真正组成程序的机器指令存放在.text段中。一般情况下，在.text段中不进行数据项的定义。.text 段中包含名为标号(label)的符号，这些符号用于标识跳转和调用的程序代码位置，但是位于指令助记符之外。

所有全局标号必须在 .text 段中声明，否则该标号就不能被 Linux 连接程序和 Linux 加载程序在你的程序之外看到。



### 8.1.5 标号

标号是一种类型的书签，用于描述程序代码中的某个位置，由于它拥有一个名字，因而比毫无装饰的内存位置更加容易记忆。标号用于标识转移指令应该跳转到的位置，也可为可调用的汇编过程起个名字。

下面是我们需要了解的关于标号的最重要的内容：

* 标号必须以字母开头；否则用下划线，句号或者问好开头。后三种对于汇编编译器来说，有着特殊含义，所以在了解 NASM 如何解释它们之前，不要使用它们。
* 当定义标号时，后面必须跟着一个冒号。这主要是告诉 NASM，被定义的标识符是一个标号。如果没有冒号的话，NASM 会像凌空踢球一样一脚把它踢出来，不会标记任何错误，但是如果有冒号定在那里的话，就可以防止一个敲入有误的指令助记符被误当做标号。所以请使用冒号！
* 标号是大小写敏感的。所以yikes:，Yikes:，和 YIKES:是三个完全不同的标号。

标号的作用：被用作转移指令和 call指令的目标操作数。

在 eatsyscall.asm 中只有一个标号，而且这个标号有些特殊。 _start 标号标识程序从何处开始。每一个 Linux 汇编语言程序都必须以这种方式进行标识，并且必须精确采用 _start 标号，此外这个标号必须在 .text 段的顶部标记为全局的，如前所示。

这是 Linux 操作系统的要求。Linux 下的每一个可执行程序必须在某处有一个 _start 标号，不管编写它的语言是 c ,Pacal 还是汇编。如果 Linux 加载程序找不到这个标号，它就不能正确地加载。Global 限定符告诉连接器让 _start 标号在程序的边界之外可见。



### 8.1.6 已初始化变量

像以下方式定义变量

```asm
MyByte: db 07H 				; 8 位大小
MyWord: dw 0FFFFH      ; 16 位大小
myDouble: dd 0B8000000 ; 32 位大小
```

可以将 DB 指令理解为“定义字节”。DB 预留一个字节的内存空间用于数据存储。可以将 DW 指令理解为 “定义字”。DW 预留一个字(16位或 2 个字节)的内存空间用于数据存储。可以将 DD 指令理解为“定义双字”。DD 在内存中预留一个双字的空间用于数据存储，通常用于完整的 32 位内存地址。



### 8.1.7 字符串变量

汇编中用以下方式定义字符串：

Mystr db "Hello world", 10

每一个字符都占用一个字节的大小，编译器会根据后面字符的个数预留相应的字节数。最后的数字 10 表示行结束符(EOL)

也可以使用 DW 来定义字符串，如下所示：

```asm
WordString: dw 'CQ'
mov ax,dw 
```

执行完第二条指令，ah保存字符'Q'，al保存字符'C'



### 8.1.8 通过 EQU 和 $ 推到字符串的长度

我们可以通过如下方式求出字符串的长度：

```asm
EatLen: equ $-EatMsg
```

包含 EQU 指令的语句叫做等值语句。等值语句是一种将一个值与标号相关联的方法。每当汇编编译器在编译过程中遇到一个等值语句，它都将该等值语句的值与其名字进行交换。例如

```
FieldWidth equalized 10
```

上面的汇编语句告诉汇编编译器 标号 FieldWidth 代表数值 10。一旦该值已经被定义，下面的两个机器指令就完全相同:

```
mov eax,10
mov eax,FieldWidth
```

这样做有两个优点:

* 等值通过一个值使用描述性的名字而使指令更容易理解。我们知道 10 这个值在此处的含义：它是字段的宽度
* 等值使程序更容易更改。如果在某种情况下，字段宽度从 10 变化为 12，我们只需要修改源文件中的一行代码，而不是每一处访问该字段宽度的地方。

要想在 Linux 下显示一个字符，我们不仅需要向操作系统传递字符串的地址，而且需要传递它的长度。可以通过如下方式创建一个字符串长度的等值:

EatMsg db "Hello world",10

EatLen equ 12

如果改变了字符串的长度，意味着将要改变EatLen的值。对于编译时计算而言，你只需修改字符串变量的定义，而它的长度则有 NASM 在编译时自动计算。

EatLen: equals $-EatMsg

$值代表 EatMsg的最后一个字符后面的位置，EatMsg代表字符串的开始位置。

整个原理是：结束处-开始处=长度

每次编译文件时都执行这种运算，因此任何时候 EatMsg 的内存发生改变，EatLen 的值都将被重新计算。

编译时计算还有一些其他的用途，但是这是最常见的一种，而且是一个当你作为初学者时很可能使用的用途。



## 8.2 通过堆栈实现后进先出

堆栈是一个直接构建在 x86 硬件之上的存储机制。英特尔没有发明它；自从 20 世纪 50 年代以来，堆栈一直是计算机硬件的组成部分。

x86 堆栈(和其他计算机硬件体系结构中的大部分其他堆栈)都被叫做后进先出或者 LIFO 栈。我们在堆栈顶部压入很多数据块，并且这些数据块将一直呆在堆栈中，直到我们按照相反的顺序将它们弹出。

堆栈并不存在某些单独的 CPU “壁橱”中。它就存在于普通的内存中，事实上我们称之为“堆栈”的东西实际上是一种内存数据的管理方式。堆栈是一个地方，我们可以暂时放入其中一个或两个(或需多个)32位双字，并在稍晚的时候再取出它们。它的主要好处是不需要我们给出存储数据的名称。我们将数据放入堆栈，后面不是通过内存地址而是通过位置来找回它们。

当把数据放入堆栈时，我们说，我们把数据压入堆栈；当从堆栈中取出数据时，我们说，我们把数据弹出堆栈。堆栈随着数据被压入或者被弹出而减小或增长。最新压入堆栈的项被认为是在“堆栈的顶部”。当从堆栈弹出一个项时，我们得到的是位于堆栈顶部的那一项。

在 x86 体系结构中，堆栈的顶部由名为堆栈指针寄存器的寄存器来进行标识，该寄存器的正式名称是 ESP。它是一个 32 位寄存器，里面存放着最后一个压入栈中的项的地址。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-15%20%E4%B8%8B%E5%8D%8811.47.03.png" alt="截屏2021-06-15 下午11.47.03" style="zoom:50%;" />

### 8.2.2 堆栈的内容上下跌倒

图 8-2 从广义上显示了当程序运行时，Linux 如何阻止分配给程序的内存。在内存底部的是程序中定义的三个段：.text 段位于最低的地址处，其次是 .data 段，再次是 .bss 段。堆栈一直位于程序的内存块的另一端。位于 .bss 段的末尾和堆栈的顶部之间的内存基本上是空的。

C 程序经常使用这种剩余内存空间来为那些位于堆内存中的，“已在运行中”的变量分配空间。汇编程序也可以这么做，尽管并不像听起来那么容易。需要记住的最重要的事情是：堆栈和程序(代码和已命名数据)在沙盒的相对角落里循规蹈矩地“玩耍”。堆栈朝着程序的剩余部分增长，但是除非你正在做一些真正惊人的事情，或者是愚蠢的事情，堆栈很少或者根本没有机会增大到能够撞到程序的已命名数据项或者机器指令的程度。如果出现这种情况，Linux 将会冷静地发出分段错误并且终止程序。

对于图 8-2 我的唯一警告是：程序段与堆栈的相对大小不应该照字面理解。程序代码可能有上千个字节，一个中等汇编程序中的数据可达成千上万个字节，但是所用的堆栈仍然相当小：最多几百个字节，一般低于这个值。

注意，当程序开始运行时，堆栈并不完全是空的。一些有用的东西在那里等着你。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-16%20%E4%B8%8A%E5%8D%8812.03.59.png" alt="截屏2021-06-16 上午12.03.59" style="zoom:50%;" />

### 8.2.3 Push-y 指令

我们可以采用几种方法将数据放入堆栈中，但最直接的方法涉及一组相关的机器指令，一共有 5 个：PUSH，PUSHF，PUSHFD，PUSHA 和 PUSHAD。所有指令都以相似的方式工作，它们之间的主要不同是压入堆栈的数据。

* PUSH 将一个在源代码中指定的 16 位或者 32 位寄存器值或者内存值压入堆栈。
* PUSHF: 将 16 位标志寄存器的值压入堆栈。
* PUSHFD: 将 Eflags 寄存器的全部 32 位值压入堆栈。
* PUSHA: 将所有的 8 个 16 位通用寄存器压入堆栈。
* PUSHAD: 将所有的 8 个 32 位通用寄存器压入堆栈。

下面是 PUSH 系列指令的一些使用举例：

```
pushf           ; 将标志寄存器压入堆栈。
pusha           ; 将 AX, CX, DX, BX, SP, BP, SI 和 DI 按此顺序一次性压入堆栈。
pushad          ; 将 EAX, ECX, EDX, EBX, ESP, EBP, ESI 和 EDI 按此顺序一次性压入堆栈。
push ax         ; 将 AX 寄存器压入堆栈
push eax        ; 将 EAX 寄存器压入堆栈
push [bx]       ; 将存放在 BX 里的内存中的字压入堆栈
push [edx]      ; 将存放在 EDX 里的内存中的双字压入堆栈
push edi        ; 将 EDI 寄存器压入堆栈
```

PUSH 采用以下方式处理 32 位操作数：首先，ESP 递减 32 位(4个字节)，指向堆栈段的一个四四节长的空白区域。然后将压栈的数据写入 ESP 指定的内存中。

PUSHA 从 286 处理器开始才添加到指令集，在 8086/8088 处理器中并不存在。

PUSHFD 和PUSHAD 从 386 处理器才开始添加到 x86 指令集。

因为 Linux 至少需要运行在 386 上，所以可以假设，任何 Linux 安装都支持 PUSHA，PUSHFD和 PUSHAD。

SP 初始位置与当前位置(栈顶)之间的所有内容包含真正的数据，这些数据被显式地压入堆栈，并且以后可以从堆栈中弹出。其中有些是在运行操作系统之前被操作系统压入堆栈的。

哪些数据可以压入堆栈，哪些数据不可以压入堆栈，这比较复杂，取决于你所使用的 CPU 。任何 16 位 和 32 位通用寄存器都可以被单独压入堆栈。但是 x86 CPU.不能将 8 位寄存器压入堆栈。立即数可以被压入堆栈，但是只有在 286 或者更高的处理上才行。(在 Linux 操作系统下这将永远为真。)用户模式 Linux 程序任何情况下都不能将段寄存器压入堆栈。

跟踪所有这一切曾经是 DOS 时代的一个难题。

PUSHAD 和 PUSHA的完整操作 

```
if(OperandSize = 32) { //PUSHAD instruction
	Temporary = ESP;
	Push(EAX);
	Push(ECX);
	Push(EDX);
	Push(EBX);
	Push(Temporary);
	Push(EBP);
	Push(ESI);
	Push(EDI);
}
else { //OperandSize = 16, PUSHA instruction
	Temporary = SP;
	Push(AX);
	Push(CX);
	Push(DX);
	Push(BX);
	Push(Temporary);
	Push(BP);
	Push(SI);
	Push(DI);
}
```



### 8.2.4 POP 指令 

一般来说，压入堆栈的内容必须要弹出来，否则你可能以若干种不同的麻烦之一结束程序。将堆栈中的数据项弹出来可通过另外一组指令五重奏来完成：POP，POPF，POPFD，POPA，POPAD。正如预想的那样，POP 是一个通用的，一次处理一个数据项的弹出指令，而 POPF 和 POPFD 专门用于从堆栈中弹出标志寄存器。POPA 从堆栈中弹出 16 个字节的数据到 8 个 16 位的通用寄存器中。POPAD 是 PUSHAD 的反向操作，它将栈顶的 32 个字节弹出到 8 个 32 位通用寄存器中。以下是一些例子：

```
popf     ; 从栈顶弹出两个字节到标志寄存器中。
popa     ; 从栈顶弹出 16 个字节到AX，CX，DX，BX，BP，SI和DI，方向和压栈时刚好相反，
popad.   ; 从栈顶弹出 32 个字节到EAX，ECX，EDX，EBX，EBP，ESI和EDI，方向和压栈时刚好相反，

popcx    ; 从栈顶弹出两个 2 个字节到 CX
pop esi  ; 从栈顶弹出 4 个字节到 esi 中
pop [ebx] ; 从栈顶弹出 4 个字节到 EBX 中的值所指定的内存中。
```

向 PUSH 一样，POP 只能操作 16 位或者 32 位操作数。

当 POP 指令被执行时，工作顺序是这样的：首先，当前存放在 ESP 中的值所代表的地址处的数据(无论是 16 位值，还是 32 位值，取决于操作数)被从堆栈中复制下来，然后放入 POP 的操作数中，无论你指定该操作数是什么；此后，ESP 递增步长为操作数的长度，这样，实际上 ESP 在堆栈中朝着远离低内存的方向上移动两个或四个字节。

对与 x86 而言，除非栈完全为空，否则 SP 指向的永远是真实的数据，而不是空白的空间。

需要记住一点：**POPA 和 POPAD 将把当前堆栈指针寄存器的值压入堆栈，并不改变 SP/ESP 中的值，而是在EDI，ESI，EBP加载后递增**

POPAD 和 POPA 的完整操作：

```
if(OperandSize == 32) {
	//Instruction == POPAD
	EDI = Pop();
	ESI = Pop();
	EBP = Pop();
	ESP = ESP + 4; //skip next 4 bytes of stack
	EBX = Pop();
	EDX = Pop();
	ECX = Pop();
	EAX = Pop();
}
else {
	//OperandSize == 16, instruction == POPA
	DI = Pop();
	SI = Pop();
	BP = Pop();
	ESP = ESP + 2; //skip next 2 bytes of stack
	BX = Pop();
	DX = Pop();
	CX = Pop();
	AX = Pop();
}
```

当执行指令`push ax`,此时 AX 的值为1234，那么堆栈从上到下依次保存 12，34，它的最低有效字节存放到 ESP 中，最高有效字节存放到 ESP+1中。（记住两个字节可被作为一个单位一次压入到堆栈中）

**MOV 指令不会操作 Flags 或者 EFlags寄存器，如果想加载一个 Flags 或者 EFlags 的副本到某一寄存器中，必须使用PUSHF 或者PUSHFD 指令 将 Flags 或者 EFlags 的值压入堆栈，然后再使用 POP 指令将Flags 或者 EFlags 的值从堆栈中弹出到选定的寄存器中。 **

比如，要想将 Flags 寄存器中的值放入 BX 寄存器中，可通过如下指令完成：

```
PUSHF     ; 将 Flags 寄存器压入堆栈
POP BX    ; 立即将
```

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-16%20%E4%B8%8B%E5%8D%888.55.32.png" alt="截屏2021-06-16 下午8.55.32" style="zoom:67%;" />

并非 EFlags 中的所有位都能被 POPFD 改变。当从堆栈中弹出一个值到 EFlags 中时，VM位 和 RF 位不会受到影响。



### 8.2.5 临时存储

堆栈被视为一个短期存放数据的地方。存放在堆栈中的数据项没有名字，并且一般情况下必须按照与进入堆栈相反的顺序弹出。

堆栈的一个非常好的应用是它允许数量确实太少的寄存器“身兼多职”。如果需要一个寄存器来暂时存放某些即将被 CPU 操作的值，而所有寄存器刚好都在使用中，可以将其中一个繁忙的寄存器的值压入堆栈中。当你使用完寄存器，再将原来的值从堆栈中弹出——这样，在并非真的拥有一个额外寄存器的情况下，你已经获得了一个额外的寄存器的好处。(当然，代价是花费在移动那个寄存器的值到堆栈中和将其从堆栈中弹出所需要的时间。我们当然不希望在需要频繁重复的循环中做这件事)

在程序的执行过程中，短期存储是堆栈最简单，最明显的用法，但是，它最重要的用途可能是程序调用和 Linux 内核服务。现在，我们已经了解了堆栈的相关知识，可以揭开 INT 指令的神秘面纱了。



## 8.3 通过 INT 80 使用 Linux 内核服务

eatsyscall.asm

```asm
; 可执行程序明 : EATSYSCALL
; 版本 : 1.0
; 创建日期 : 2021-1-9
; 作者 : 王俊
; 描述 : 一个简单的 Linux 下的汇编应用程序，使用  NASM 2.13.02
;   演示了  Linux INT 80H  系统调用显示文本的用法
;
; 使用这些命令生成：
; nasm -f elf -g -F DWARF eatsyscall.asm -o syscall.o
; ld -m elf_i386 -o eatsyscall eatsyscall.o
;

SECTION .data                   ; 包含已初始化的数据的段


EatMsg: db "Eat at Joe's!",10
EatLen: equ $-EatMsg

SECTION .bss                    ; 包含未初始化的数据的段
SECTION .text		        ; 包含代码的段

global _start                   ; 连接器需要据此找到入口点！

_start:
	nop			    ; 这个无操作指令让 gdb 非常高兴
	mov eax,4		; 指定 sys_write 系统调用
	mov ebx,1 		; 指定文件描述符1：标准输出
	mov ecx, EatMsg	        ; 传递显示信息的偏移地址
	mov edx,EatLen 		; 传递显示信息的长度
	int 80H			; 进行系统调用来输出文本到标准输出
	
	mov eax,1 		; 指定 Exit 系统调用
	mov ebx,0		; 返回一个零代码
	int 80H			; 进行系统调用来终止代码
```

上述源码做的唯一真正工作：将一行文本显示到 Linux 控制台。这个程序的核心宗旨是：通过使用带 80H 参数的 INT 指令，实现对于 Linux 操作系统内核服务的调用。

Linux 以神圣的方式控制着机器的所有最重要的部分：磁盘驱动器，打印机，键盘，各种接口(以太网，USB，蓝牙等)和显示器。同时，Linux 也像一个生活在一座连接计算机的所有这些部件的桥梁下面的恶魔：你告诉巨魔你想做的事情，然后巨魔会为你代劳。

Linux 提供的服务之一是简单地访问个人电脑显示器。那么，如何使用 Linux 服务？我们必须通过 Linux 内核请求这些服务。有一种使用起来非常容易但是理解起来比较棘手的方法：通过软件中断。



### 8.3.1 不中断任何事情的中断

在 eatsyscall.asm 程序中列举过的两次真实的示例能够很好地解释软件中断和 Linux 服务的本质。正如我先前暗示的那样，Linux 让库例程(着眼于某一单一任务的机器指令序列)在它的内部隐藏起来。每个库例程指令序列都做一些有用的事情——从文件中读取数据，发送数据到文件中，获取当前时间，访问网络端口，等等。Linux 使用这些库例程来完成自己的工作，同时也允许程序员从自己的程序中访问它们。

所有的机器指令序列都拥有地址，那么为什么不公布一份所有这些有用例程的地址列表呢？这里存在两个问题：

1. 允许用户空间程序对操作系统内部进行访问是危险的。恶意软件编写者可以通过修改操作系统的关键组成部分来监视用户的活动，捕获击键并转发给其他地方，等等。
2. 任意给定指令序列的地址从一个安装到到另一个安装会有所变化，不仅如此，甚至(随着软件不断被从个人电脑上安装，配置以及移除)从一天到另一天也会有所变化。Linux 在不断进化，完善和在现有基础上进行修复。修复和完善代码涉及增加，修改和删除机器指令，而这些会改变那些隐藏的代码序列的大小——且作为结果，它们的位置也会发生变化。

解决方案非常巧妙。有一种调用 Linux 内部服务例程的方法，它不需要依赖任何地址。大多数称之为内核服务调用门，它是一个戒备森严的门户，位于程序运行的用户空间和 Linux 神/巨魔完成其工作的内核空间之间。调用门方案通过一个 x86 软件中断实现。

在 x86 最开始的一段内存中，段地址和偏移地址均为 0 的地方，有一个特殊的具有 256 个数据项的查找表。每一项都是占用 4 个字节，包括段地址和偏移地址的完整内存地址。任何 x86 机器上的第一个 1024 字节的内存被预留出来存放此表，不能在那里存放其他的代码或数据。

表中的每一个地址都被叫做中断向量。这张表作为一个整体被叫做中断向量表。每个向量都有一个 0 到 255 之间的编号。占用表中 0 到 3 字节的向量是向量0，占用表中 4 到 7 字节的向量是向量 1。依次类推。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-16%20%E4%B8%8B%E5%8D%8811.53.20.png" alt="截屏2021-06-16 下午11.53.20" style="zoom:50%;" />



这些地址没有一个像个人电脑 BIOS 例程那样烧制到永久性内存中。当机器启动时，Linux 和 BIOS 向很多位于中断向量表中的插槽填写关于该插槽本身的中断程序的地址。每一个版本的 Linux 都知道其内部部件的位置，并且当升级到新的 Linux 版本时，这个新的版本会向很多位于中断向量表中的插槽填写升级之后的准确地址。

从一个 Linux 版本到另一个 Linux 版本中没有什么变化的是存放特定地址中断编号。换句话说，从最早的 Linux 发行版本开始，中断 80H 就指向进入最漆黑的通往(将近 200 个)的，单独的 Linux 内核服务例程的支线。在大多数 Linux 发行或版本，程序都能通过中断向量表中的 80H 项来访问该调度程序。

程序不必非得通过查找中断向量表才能获得它们的地址(实际上也无权访问，因为它属于操作系统)。但是，你不一定非要直接访问表中的地址。x86 处理器包括一条机器指令，它拥有特殊的使用中断向量表的权利。eatsyscall.asm 使用 INT(中断)指令来请求在屏幕上显示一条字符串的 Linux 服务。eatsyscall.asm 在两个地方都有一个 INT 80H 指令。当执行一条 INT 80H 指令时，CPU 查找中断向量表，并从 80H 表项中取出地址，然后再将执行流程跳转到给地址。从用户空间到内核空间的过程非常干净，而且非常可控。而另一边，位于存储在表中 80H 项中的地址处的调度程序开始执行，开始完成你的程序请求的服务。

这一过程如图 8-5 所示。当 Linux 在计算机引导期间被加载时，它为计算机准备使用所做的诸多事情之一就是把正确的地址放入中断向量表中的几个向量中。其中一个地址就是内核服务调度的地址，它将进入插槽 80H

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/INT.png" alt="截屏2021-06-17 上午12.13.10" style="zoom:67%;" />



以后，当在 Linux 控制台的命令行中键入程序名称 eatsyscall 时，Linux 加载 eatstscall 的可执行文件到用户空间内存，并运行它执行。为了访问内核服务，eatsyscall 根据需要执行了 INT 80H。除了需要知道在中断向量表中的编号之外，eatsyscall 继续处于无知状态，它只是简单地让 INT 80H 指令和中断向量 80H 将它带到需要的地方。

而在幕后， INT 80H 指令做了一些其他事情，在沿着向量 80H 所示的地址进入 Linux 内核之前，它把下一条指令(即紧跟在 INT 80H 指令后面的那条指令)的地址压入堆栈。以帮助 CPU 在 “远足” 到 Linux 内部之后依然能够找到返回 eatsyscall 的路线。

现在，Linux 内核服务调度程序控制着对于这 200 个单独的服务例程的访问。它是如何知道执行哪一个例程的呢？我们要告诉调度程序需要哪个服务，这可以将服务的编号放入寄存器 EAX 中来实现。在开始工作之前，调度程序可能还需要将其他信息，并且期待你在正确的位置提供该信息(它们几乎总是在各种各样的寄存器中)

例如下面的代码：

```asm
mov eax,4		; 指定 sys_write 系统调用
mov ebx,1 		; 指定文件描述符1：标准输出
mov ecx, EatMsg	        ; 传递显示信息的偏移地址
mov edx,EatLen 		; 传递显示信息的长度
INT 80 H
```

这个指令序列要求 Linux 显示一个文本字符串到控制台。第一行建立一个关键信息：需要请求的服务的编号。在本例中，它是 sys_write，服务编号为 4 它能够将数据写入一个 Linux 文件中。请记住，几乎所有东西都文件，其中也包括控制台。第二行告诉 Linux 写入哪个文件：标准输出。每个文件都必须有一个数字的文件描述符，前3(0,1,2)个是标准的，并且永远不会改变。标准输出的文件描述符是1。

第三行把将要显示的字符串的地址放到 ECX 寄存器中。Linux 通过它来知道我们想要显示的内容。调度程序希望我们将地址存入 ECX 寄存器中，但是那个地址只是字符串的开始位置。Linux 还需要知道字符串的长度，我们将那个值放在 EDX 寄存器中。

当内核服务编号，字符串的地址和字符串的长度被放入适当的寄存器之后，我们通过执行 INT 80H 到调度程序旅行了一圈。INT 指令是它需要的所有内容。执行跨过“桥梁”进入内核空间，Linux 巨魔在那里读取 ECX 处的字符串，并且通过它那或多或少有些保密的机制，将其发送到控制台。大多数情况下，这是一件好事：描述程序机制可能需要很多的信息，它就像描述你的个人生活一样一言难尽。



### 8.3.2 再次返回

上面讲解了进入 Linux 内部。那么程序如何再次返回呢？向量 80H 中的地址将执行带入内核服务调度程序。

要想继续执行在 INT 80H 指令之前所遗留的内容，Linux 必须在一个完全可靠的地方找回返回地址，而那个完全可靠的地方不是别处，正是栈顶。

INT 80H 指令在进入一个未知地址之前，先将一个地址压入堆栈。这个地址就是下一条即将轮到执行的指令的地址：紧跟在 INT 80H 指令后面的那条指令的地址。这个位置是完全可靠的，因为，正如一台机器上只有一个中断向量表一样，在任何一个时间段中，只有一个堆栈在工作，这意味着只存在一个堆栈的栈顶——也就是 ESP 寄存器所指向的地址——通过将地址从栈顶弹出，然后跳转到那个地址，Linux 总是能够将执行送回到调用它的程序中。

这一过程如下图所示，它是图 8-5 的延续。正如 INT 指令将一个返回地址压入堆栈中，然后跳转到存放在某一特定向量中的地址一样，有一条“配对”指令能够将返回地址从堆栈中弹出，然后跳转到这个地址，**这条指令就是 IRET(用于中断返回)**，它完成这一复杂却可靠的系统(在你不知道地址的情况下，跳转到这个地址)。再次地，其中的技巧是知道在哪里可以可靠地找到地址，在本例中，那个地方就是堆栈。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-17%20%E4%B8%8B%E5%8D%8812.16.53.png" alt="截屏2021-06-17 下午12.16.53" style="zoom:50%;" />



实际上，软件中断机制压入和弹出堆栈的内容不止这些，但是它的发生非常透明，等有了基础，应该去尝试编写自己的软件中断例程。那是在内核区编程，我鼓励你完成这一目标。



### 8.3.3 通过使用 INT 80H 退出一个程序

在 eatstscall.asm中，有第二个 INT 80H指令，它完成一项谦卑却又关键的工作: 关闭程序，将控制权返回给 Linux。这比它的实际情况听起来要简单，一旦你了解了更多 Linux 内部知识以后，你将开始重视那项必不可少，既要启动一个进程又要关闭一个进程的工作。

从自己的程序的角度来看，它非常简单：将 sys_exit 服务的中断号放入 EAX 寄存器中，把返回值放入 EBX 寄存器中，然后执行 INT 80H :

```asm
mov eax,1       ; 指定退出系统调用
mov ebx,0       ; 将零作为返回值
int 80H         ; 进行系统调用以终止程序
```

返回值是一个数字，它的内容没有任何限制(除了必须适合存放在 32 位寄存器中之外)，但是按照惯例，返回值为 0 意味着"一切工作都完成了；正常关闭"。返回值为 0 以外的数字则通常表明发生了某种类型的错误。请记住，在更大一些的程序中，必须留意那些没有按照预期工作的事情：找不到磁盘文件，磁盘驱动器已满，等等。如果程序不能完成其工作，必须提前终止，它应该以某种方式告诉你(或在某些情况下，另一个程序)哪里出了问题。返回值就是一个能够做到这一点的好办法。

我们编写的每一个程序都必须以这种(通过内核服务调度程序来进行 sys_exit 调用的)方式退出。



### 8.3.4 软件中断 VS 硬件中断

软件中断是一种 CPU 注意自身之外世界的机制，硬件中断是一种 CPU 注意自身之外世界的机制。

一个内置在电脑中的相当复杂的电气系统能够让电路板发送信号给 CPU。CPU 芯片上的一个金属针被电路板设备(如磁盘驱动器，控制器或一个串口板)从某一伏特电压等级变为另一等级。通过这个引脚，外部设备能够“轻拍 CPU 的肩膀”。CPU 将这种“轻拍”识别为硬件中断，在中断向量表中都预留一个 “插槽”(表项)。在这个插槽中，存放的是一个中断服务例程(ISR)的地址，该中断服务例程执行一些与轻拍 CPU 肩膀的设备相关的事情。例如，如果中断信号来自一个串口电路板，CPU 将会允许该串口板从它自己传输一个字符字节到 CPU 中。

硬件中断和软件中断之间的唯一不同之处是触发到中断向量表之旅的事件。在软件中断中，触发事件是软件的一部分，也就是说，一条 INT 指令。在硬件中断中，触发事件是一个应用于 CPU 芯片本身的，没有任何 INT 指令插手这一过程的电信号。当意识到有电脉冲触发中断时，CPU 自己把返回地址压入堆栈，但是，当 ISR 执行完毕，必须通过一条 IRET 指令将执行 “送回家”，就像在软件中断中所做的一样。

这里所说的用于在一个软件中断调用后的“返回”机制，实际上比听起来更加普遍。在本书的后面，我们将开始把程序分割成过程，这些过程通过一对指令来进行访问：CALL 和 RET。CALL 将下一条指令的地址压入堆栈，然后跳转到一个过程；在该过程的结尾处，一条 RET 指令将该地址从堆栈的栈顶弹出，然后允许执行继续捡起 CALL 指令后面的内容。



### 8.3.5 INT 80H 和可移植性崇拜

Unix 世界一直秉承这样的理念，即一个程序应该能够在不需要更改的情况下被重新编译，并且能够正确地运行在完全不同的 CPU 体系结构上的 Unix 上。这仅仅是勉强可以的，只对那些用简单语言(C)编写的相对简单的程序适用，该简单语言使用计算机系统所能提供的"最小公分母" 子集。进入精心制作的图形用户界面(GUI)应用程序和现代的外设之后，你将面对很多拥有大量复杂的应用程序编程接口(API)的，不兼容的软件库，以及那些本不应该存在却非常不礼貌地存在着的设备驱动程序怪癖。

再加上近年来所有这些 API 和新的，更高级的语言(比如 Python)的不断演变，你在去年编写的程序甚至可能今年就不在同一平台上编译了，你将面对我在很多年前得出的结论：嵌入式便携性就是一个神话。我们现在的平台如此复杂，以至于每一个应用程序都基于特定的平台。跨平台编码可以做，但必须修改源代码，通常折中于必须使用条件编译来实现——**本质上来讲，条件编译就是程序里面的 IF 语句集，该语句通过一系列传递给编译器的参数来改变源代码；**如果在 x86 上的 Linux 进行编译，编译这些语句；如果在为 x86 上的 BSD Unix 进行编译，编译其他语句，等等。条件编译，仅仅是佩戴在残酷的底层现实上的面具：计算机是不同的。计算机系统是不断进化的。

在本节讲的 Linux 内核服务调用实际上是针对特定的 Unix 的 Linux 实现的。其他的 Unix 实现以不同的方式处理。在 Unix 操作系统的 BSD 家族中，内核服务调度程序也是通过INT 80H 实现的，但是，参数被传递到内核的堆栈上，而不是寄存器中。无论是好是坏，它们是不同的，Linux 汇编程序将无法运行在 BSD Unix 下。(要想了解“可移植性”的编码，你应该学习 Python，这是一种极具魅力的非常高级的语言，并且几乎出现在所有的 Unix 实现上。)

但是，在 Linux 的发行和甚至跨年的升级中，内核服务列表本省只是改变了一点点，改变更多的主要是最近几年添加到内核的更加神秘的服务。如果在 Linux 的 x86 发布下编写的汇编代码不会等同地运行在另一个 x86 发布中，它并不是由于调用内核服务的方式造成的。

汇编语言不是也不能是可移植的。它不是为实现移植而设计的。另一方面，也不要让任何人试图说服你去做这件事。



## 8.4 设计一个有价值的程序

要想编写一个有价值的汇编程序，如果没有条件转移语句，会很困难。



### 8.4.1 问题定义

我们将工作在 Linux 下。

数据存在于磁盘文件中。

我们事先不知道任何一个文件的大小。

文件没有最大值或最小值。

我们将使用 I/O 重定向技术将文件名称传递给程序。

所有输入文件都采用相同的编码方案。这个程序可以假设在一个文件中的字符“a”与另一个文件中的字符“a”所采用的编码方式相同。

我们必须以原来的形式保留原始文件，而不是从原始文件读出数据，然后将其再写回到原始文件中。(这是因为如果进程崩溃，我们会在没有完全生成输出文件的情况下破坏原有文件)



### 8.4.2 从伪代码开始

这是一种可能采用的陈述形式：

* 从输入文件读如一个字符。
* 将该字符转换成大写字符(如果需要的话)。
* 将字符写入到输出文件中。
* 重复该过程直至任务完成。



### 8.4.3 连续改进

下一轮改进：

* 从标准输入(stdin)中读如一个字符。
* 测试该字符以判断其是否为小写字符。
* 如果该字符为小写字符，则将其通过与 20H 相减来将其转换为大写字符。
* 将字符写入标准输出(stdout)。
* 重复该过程直到任务完成。
* 通过调用 sys_exit 来退程序。



我们如何知道输入文件已经没有字符？这可能需要一些研究，但是在大多数操作系统(包括 Linux)中，你调用的用于从文件中读取数据的例程都会有一个返回值。这个值可以表明一次成功的读取，一次错误的读取或者某者特例结果。例如；文件是否结束(EOF)。一个扩展的解决方案版本的伪代码可能像这样：

* 从标准输入(stdin)中读如一个字符。
* 测试一下是否已经到达了文件的结尾(EOF)。
* 如果已经到达了文件的结尾，我们已经完成任务，所以跳转到 exit。
* 测试该字符以判断其是否为小写字符。
* 如果该字符为小写字符，则通过将其与 20H 相减来转换为大写字符。
* 将字符写入标准输出(stdout)。
* 回去读取另一个字符。
* 通过调用 sys_exit 来退出程序。

随着语句的添加，对那些代表跳转目标的语句添加标号会给我们带来帮助，这样可避免混淆跳转目标，即便是在伪代码中。通过将相关语句组合在一起，它也有助于我们将伪代码分解成子块。我们迟早会得到以下内容类似的结果:

Read : 设置用于 sys_read 内核调用的寄存器。

​			 调用 sys_read 从标准输入中读如一个字符

​			 测试 EOF

​             if 我们到了 EOF，跳转到 Exit

​             测试该字符以判断其是否为小写字符

​			 if 它不是小写，跳转到 Write

​            通过将字符与 20H 相减来将其转换为大写字符。 

 Write：为写内核调用设置相关寄存器

​				调用sys_write 向标准输出写数据

​				跳回到标号 Read 处，读取另一个字符。

Exit:    设置通过 sys_exit 来停止程序所需的寄存器，调用 sys_exit



```
; 可执行程序明 : uppercaser1
; 版本 : 1.0
; 创建日期 : 2021-6-17
; 作者 : 王俊
; 描述 : 一个简单的 Linux 下的汇编应用程序，使用  NASM 2.13.02
;   将一个文本文件中小写字母转换为大写，其他字符不变，写入到另一个文件
;
; 使用这些命令生成：
; nasm -f elf -g -F DWARF uppercaser1.asm -o uppercaser1.o
; ld -m elf_i386 -o uppercaser1 uppercaser1.o
; 运行方式，假设当前目录下有一文本文件 t1.txt，执行命令: ./uppercaser1 > t2.txt < t1.txt 
; 程序将t1.txt中的小写字母转换为大写，其他字符不变，转换后的文件保存在t2.txt，若t2.txt不存在，则首先创建该文件，再将结果写入
;         
section .bss
    Buff resb 1

section .data

section .text
    
    global _start

_start:
    nop

Read:
    mov eax,3            ;   指定 sys_read 调用
    mov ebx,0            ;   指定文件描述符0：从标准输入
    mov ecx,Buff         ;   传递即将从中读取数据的缓冲区地址
    mov edx,1            ;   告诉 sys_read 从标准输入读入一个字符
    int 80H              ;   调用 sys_read
    cmp eax,0            ;   观察 sys_read在EAX寄存器中的返回值。
    je Exit              ;   如果为零(意思是EOF)则跳转到Exit
                         ;   如果不为零，则测试它是否为一个小写字母

    cmp byte [Buff],61H  ;   将输入字符与小写字母 'a' 比较
    jb Write             ;   如果在 ASCII 表中比 a 小，则不是小写字符

    cmp byte [Buff], 7AH ;   将输入字符与小写字符 'z' 比较
    ja Write             ;   如果在 ASCII 表中比 'z' 大，则不是小写字符
                         ;   此时，我们已经拥有了一个小写

    sub byte [Buff],20H  ;   从小写字符中减去 20H，得出相应的大写字符
                         ;   然后将该字符写出到标准输出



Write:
    mov eax,4            ;  指定 sys_write 调用 
    mov ebx,1            ;  指定文件描述符1：标准输出
    mov ecx,Buff         ;  传递要写出的字符的地址
    mov edx,1            ;  传递要写出的字符的数量
    int 80H              ;  调用 sys_write
    jmp Read             ;  然后跳转到开始处，获取另一个字符

Exit:
    mov eax,1            ;  退出系统调用的代码
    mov ebx,0            ;  将零作为返回值而返回 Linux 
    int 80H              ;  进行内核调用以退出程序

```



Buff 是一个尚未初始化的变量，因此位于程序的 .bss 段中。Buff 没有初始值，并且不包含任何内存，直到我们从 stdin 中读如一个字符并将其存储在那里。

由于内存地址(如 Buff)只是指出内存中的一个没有指定固定大小的位置，所以必须在 CMP 和它的内存操作数之间放一个限定符 BYTE，告诉 NASM，他要比较两个 8 位的值，在本例中，这两个 8 位值是一个 ASCII 字符(如 '"w")和一个十六进制值(如 7Ah)



### 8.4.4 不可避免的 “哎呀！”时刻

你可能会认识到，有一些用汇编语言实现的，更短的完成某事的方法，它能比直接从字面翻译伪代码带来更好的效果。学无止境，无论认为自己学的多么棒，你都永远处于学习状态。

一个很好的例子，程序没有检测到错误，它假设用户为 I/O 重定向输入的输入文件已经存在并且没有损坏，文件里面已经存有数据，在当前用于输出文件的驱动器也会有空间，等等。这种操作方式很危险，即使它能够侥幸完成。与文件相关的 Linux 系统调用都能返回错误值，任何使用它们的程序员都应该检查这些错误，并据此采取响应的行动。

总之，在整个过程中，总要上演几次你必须认真推敲伪代码，甚至将其完全推翻，然后再重新开始的场景。当你处于将伪代码转换为机器指令的最后阶段时，这种(令人讨厌的)情况经常发生。请做好思想准备。

如果你了解一些关于低级文件输入/输出的相关知识：Linux 的 sys_read 内核调用不仅限于一次返回一个单个字符，你将一个缓冲区地址传递到 sys_read中，sys_read 将尝试从输入文件中向该缓冲区填充字符，可以指定填充的字符数，前提是输入文件中有那么多字符。对sys_read 的一次简单调用就能够一下子带给你 很多个字符，这样就可以减少 Linux 在切换文件系统和你的程序上所花费的时间。

在改进问题解决方案的伪代码过程中，你应该已经知道了前期步骤。有很多你的大脑和指尖都需要的诸如此类的细节，你不可能一个下午就将它们变为永不磨灭的记忆。这种启示经常迫使你“备份”一个或两个迭代，并且重新改写某些伪代码。



### 8.4.5 扫描缓冲区

Unix 的读写内核调用是面向缓冲区而非面向字符的，因此我们必须重新修改伪代码以填充字符到缓冲区中，然后再处理这些缓冲区。这里添加了从磁盘读取缓冲区，扫描和转换缓冲区中的字符，以及后来将其写回到磁盘缓冲区所需的一切内容。(当然，缓冲区必须从一个字符扩大到某些有用的大小，如 1024 个字符)。缓冲区的技巧要点是建立一个指向缓冲区的指针，然后检查(如有必要)和转换指针所代表处的地址处的字符。然后将指针移动到缓冲区的下一个字符，做同样的事情，重复该过程，知道已经处理完缓冲区中的所有字符。

扫描缓冲区是一个很好的关于汇编语言循环的例子。

Read: 为 sys_read 内核调用设置寄存器

​			调用 sys_read 从标准输入读入满满一缓冲区的字符

​			将读入字符的数量存放到 esi 寄存器中

​			测试 EOF (eax = 0)

​			if 我们到了文件的结尾，跳转到 Exit



​             将缓冲区地址放入 ebp 中

​			将读入缓冲区中的字符的数量放入 ecx 寄存器中



Scan 将[ebp+ecx] 处的字节与'a'比较

​		if 该字节在 ASCII 表中的顺序比 'a' 小，则跳转到 Next 处

​		将[ebp+ecx] 处的字节与'z'比较 

​        if 该字节在 ASCII 表中的顺序比 'z' 大，则跳转到 Next 

​		通过将该字符与 20H 相减来将其转换为相应的大写字符

​		

Next: 将 ecx 寄存器递减1

​			if 不为零，跳转到标号 Scan



Write: 为写内核调用设置寄存器。

​			调用 sys_write 将处理后的缓冲区内容写到标标准输出

​             跳回标号 Read处，然后获取另一个充满字符的缓冲区



Exit: 通过 sys_exit 来终止程序而设置寄存器

​		调用 sys_exit





### 8.4.6 缓冲溢出(“Off By One”)错误

在伪代码中有一个漏洞(bug)，它是所有汇编语言初学者最常见的错误之一：传说中的缓冲溢出(“off by one”)错误。EBP 和 ECX 之和将指向一个超出缓冲区结尾的地址。当 ECX 中的计数值为零时，仍然有一个字符(在缓冲区的最开始的那个)没有受到检验，并且保持不变。解释这个漏洞来源的最简单方法就是将其画出来。如图 8-7 所示：

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-18%20%E4%B8%8A%E5%8D%8811.19.02.png" alt="截屏2021-06-18 上午11.19.02" style="zoom:50%;" />

​			              

每当地址偏移和某种计数值合二为一的时候，这种问题都有可能发生，计数从 1 开始，而偏移量从 0 开始。字符 #1 实际上位于相对于缓冲区开始位置偏移地址为 0 的地方，字符 #2 在偏移地址为 1 的地方，等等。我们正在尝试将一个 ECX 中的值既作为计数值来用，又作为偏移地址来用，如果缓冲区里的偏移地址假定从 0 开始，一个缓冲溢出错误将不可避免。

解决方法很简单：在开始扫描前，将缓冲区的地址(它被存储在 EBP 中)递减 1，EBP 现在指向缓冲区的第一个字符前面的内存位置。EBP 以这种方式设置之后，我们就可以将 ECX 中的值既作为一个计数值来用，又作为一个偏移地址来用了。当ECX 中的值递减为 0 时，我们已经处理了 “g” 字符，并且退出循环。

下面是循环的机器指令：

; 设置寄存器，用于转换缓冲区这一步骤

​	mov ecx, esi              ;  把读入的字节数放入 ecx 寄存器中。

​    mov ebp,Buff           ;  把缓冲区的地址放入 ebb 寄存器中。

​	dec ebp



; 搜查该缓冲区，并将小写字符转换为大写字符:

Scan: 

​		cmp byte [ebx+ecx], 61H       ;  测试输入字符，将其与小写字符 'a' 相比较

​		jb Next									  ;  如果 ASCII 码值比 'a' 的 ASCII 值小，则不是 小写字符

​	    cmp byte [ebx+ecx], 7AH      ; 测试输入字符，将其与小写字符'z' 相比较

​        ja Next                                      ;  如果 ASCII 码值比 'z' 的 ASCII 值大，则不是 小写字符



; 此时 ，我们有了一个小写字符

​	   sub byte [ebp+ecx],20H          ;  与 20H 相减，得到大写字符

​	

Next: dec ecx

​		 jnz Scan                                   ;  如果不为零则跳转到 Scan





纯粹主义者认为，在循环开始前递减 EBP 中的地址是一个冒险的黑客行为。它们有一半是正确的，如果程序试图在该位置写入一个值，则可能破坏另一个变量，或者导致一个分段错误的结果，这里，循环的逻辑并不要求在那个特定的地址写入数据，但是很容易误操作。

处理 off-by-one 错误的"合适" 方法就是让 EBP 一直指向缓冲区的真正开始位置，然后在循环开始时而不是在结束时递减 ECX。测试 ECX，判断其是否为零的工作仍然必须要做，但是在循环的最后，通过一条单独的 CMP 指令来完成。这样不仅能够正常工作，而且指针总是指向缓冲区内不的内存位置:

; 设置寄存器，用于转换缓冲区这一步骤

​	mov ecx, esi              ;  把读入的字节数放入 ecx 寄存器中。

​    mov ebp,Buff           ;  把缓冲区的地址放入 ebb 寄存器中。



; 搜查该缓冲区，并将小写字符转换为大写字符:

Scan: 

​		cmp byte [ebx+ecx], 61H       ;  测试输入字符，将其与小写字符 'a' 相比较

​		jb Next									  ;  如果 ASCII 码值比 'a' 的 ASCII 值小，则不是 小写字符

​	    cmp byte [ebx+ecx], 7AH      ; 测试输入字符，将其与小写字符'z' 相比较

​        ja Next                                      ;  如果 ASCII 码值比 'z' 的 ASCII 值大，则不是 小写字符

; 此时 ，我们有了一个小写字符

​	   sub byte [ebp+ecx],20H          ;  与 20H 相减，得到大写字符



Next: cmp ecx,0                              ;  判断字符计数器的值是否为 0

​			jnz Scan                               ;  如果没有，则跳转回去，继续循环



但是，这样做需要付出代价：循环内部的指令比以前多处了一条。循环次数很少时，影响并不大，但是当循环次数达到数千，数万或者数百万的话，即使是非常微小的时间片累加起来，执行速度也能明显变慢。

将所有的伪代码全部转换为汇编代码之后的完整程序如下:

```asm
; 可执行程序名：uppercaser2
; 版本：1.0
; 创建日期：2021年6月18日
; 最后修改日期：2021年6月18日
; 作者: wangjun
; 描述：一个为 Linux 编写的简单的汇编程序，使用 NASM 2.13.02
; 展示了简单的文本文件输入/输出(通过重定向)
; 为了实现从输入文件读入一块缓冲区，强制将小写字符转换为大写
; 将修改过得缓冲区写入到一个文件
; 
; 以这种方式来运行它:
; uppercaser2 > (output file) < (input file)
; 
; nasm -f elf -g -F DWARF uppercaser2.asm
; ld -m elf_i386 uppercaser2.o -o uppercaser2
;

SECTION .bss                ; 包含未初始化数据的段
    BUFFLEN equ 1024        ; 缓冲区的长度
    Buff: resb BUFFLEN      ; 缓冲区文本本身

SECTION .data               ; 包含已经初始化数据的段

SECTION .text               ; 包含代码的段

    global _start           ; 连接器需要这个来找到入口点

_start:
    nop

; 从标准输入读入满满一缓冲区文本
Read:
    mov eax,3               ; 指定 sys_read 调用
    mov ebx,0               ; 指定文件描述符0: 标准输入
    mov ecx,Buff            ; 传递要从中读入数据的缓冲区的地址
    mov edx,BUFFLEN         ; 传递一次循环中要读入的字节数
    int 80H                 ; 调用 sys_read 来填充缓冲区
    mov esi,eax             ; 复制 sys_read 的返回值并妥善保管
    cmp eax,0               ; 如果 eax=0, 则 sys_read 到了标准输入的结尾
    je Done                 ; 如果(与0相比较)相等则跳转

; 设置寄存器，用于处理缓冲区这个步骤

    mov ecx,esi             ; 将读入的字节数放入 ecx 寄存器中
    mov ebp,Buff            ; 将缓冲区的地址放入 ebp 寄存器中
    dec ebp                 ; 调整偏移地址的计数值
    
; 详细检查缓冲区，并将小写字符转换为大写字符
Scan:
    cmp byte [ebp+ecx],61H  ; 测试输入字符，将其与小写字符 'a' 相比较
    jb Next                 ; 如果 ASCII 码值比 'a' 的 ASCII 码值小，则不是小写字符
    
    cmp byte [ebp+ecx],7AH  ; 测试输入字符，将其与小写字符 'z' 相比较
    ja Next                 ; 如果 ASCII 码值比 'z' 的 ASCII 码值大，则不是小写字符

    ; 此时我们拥有了一个小写字符
    sub byte [ebp+ecx],20H  ; 与 20H 相减，得到大写字符

Next:
    dec ecx                 ; 递减字符计数器
    jnz Scan                ; 如果仍然有字符，则继续循环


Write:
    mov eax,4               ; 指定 sys_write 调用
    mov ebx,1               ; 指定文件描述符1: 标准输出
    mov ecx,Buff            ; 传递缓冲区的偏移地址
    mov edx,esi             ; 传递缓冲区数据的#个字节
    int 80H                 ; 进行 sys_write 内核调用
    jmp Read                ; 回去继续循环，加载另一满满的缓冲区数据

; 全部搞定

Done:
    mov eax,1               ; 退出 syscall 的代码
    mov ebx,0               ; 将零作为返回值返回
    int 80H                 ; 进行 sys_exit 内核调用
```



### 8.4.7 进一步学习

无论使用什么语言编程，这个过程都会很好地为你服务。当你在这个项目以及所有未来项目上继续前行时，这里是一些需要牢记的事项：

* 请记住，没有人说过你必须一次性将所有内容从伪代码转换为机器指令。是的，连续改进应该是连续的。一个完全合理的问题陈述可能既包括指令也包括伪代码。随着时间的推移，一个完全合理的问题问题陈述可能既包括指令也包括伪代码。随着时间的推移，你会不断发展适合于自己的技术，随着你逐渐变成一名越来越自信的程序员，你所需要的完善次数将会越来越少，而得到的结果则会越来越好。
* 不要害怕画图。当你试图处理一个复杂的循环或者任何需要处理许多环节的过程时，潦草地画在方格信笺上的铅笔素描指针、缓冲区等等。可以为你带来很大的帮助。
* 保存你的笔记，无论它有多么丑陋。编程过程中的记忆会变得陈旧。如果你编写了一个实用工具，并且使用了它 6 个月，在试图重新改进它之前，你可能需要对它的内部工作机制进行一下复习。将所有相关内容都存放到一个文件夹里，包括写入磁盘文件中的伪代码的打印结果。

过滤器在 Unix 工作中十分常见。

添加了错误检查的版本

```asm
; 可执行程序名：uppercaser2
; 版本：1.0
; 创建日期：2021年6月18日
; 最后修改日期：2021年6月18日
; 作者: wangjun
; 描述：一个为 Linux 编写的简单的汇编程序，使用 NASM 2.13.02
; 展示了简单的文本文件输入/输出(通过重定向)
; 为了实现从输入文件读入一块缓冲区，强制将小写字符转换为大写
; 将修改过得缓冲区写入到一个文件
; 
; 以这种方式来运行它:
; uppercaser2 > (output file) < (input file)
; 
; nasm -f elf -g -F DWARF uppercaser2.asm
; ld -m elf_i386 uppercaser2.o -o uppercaser2
;

SECTION .bss                ; 包含未初始化数据的段
    BUFFLEN equ 1024        ; 缓冲区的长度
    Buff: resb BUFFLEN      ; 缓冲区文本本身

SECTION .data                        ; 包含已经初始化数据的段
ReadError db "read error",10         ; 定义字符串，表示“表示数据读取错误”，10表示
ReadErrorLen equ $-ReadError         ; 表示字符串 ReadError 的长度 
WriteError db "write error",10       ; 定义字符串，表示“数据写入错误”
WriteErrorLen equ $-WriteError       ; 表示字符串 “WriteError” 的长度

SECTION .text               ; 包含代码的段

    global _start           ; 连接器需要这个来找到入口点

_start:
    nop

; 从标准输入读入满满一缓冲区文本
Read:
    mov eax,3               ; 指定 sys_read 调用
    mov ebx,0               ; 指定文件描述符0: 标准输入
    mov ecx,Buff            ; 传递要从中读入数据的缓冲区的地址
    mov edx,BUFFLEN         ; 传递一次循环中要读入的字节数
    int 80H                 ; 调用 sys_read 来填充缓冲区
    mov esi,eax             ; 复制 sys_read 的返回值并妥善保管
    cmp eax,0               ; 如果 eax=0, 则 sys_read 到了标准输入的结尾
    jl ReadErrorMsg         ; 如果小于(与 0 相比较)则跳转
    je Done                 ; 如果(与0相比较)相等则跳转

; 设置寄存器，用于处理缓冲区这个步骤

    mov ecx,esi             ; 将读入的字节数放入 ecx 寄存器中
    mov ebp,Buff            ; 将缓冲区的地址放入 ebp 寄存器中
    dec ebp                 ; 调整偏移地址的计数值
    
; 详细检查缓冲区，并将小写字符转换为大写字符
Scan:
    cmp byte [ebp+ecx],61H  ; 测试输入字符，将其与小写字符 'a' 相比较
    jb Next                 ; 如果 ASCII 码值比 'a' 的 ASCII 码值小，则不是小写字符
    
    cmp byte [ebp+ecx],7AH  ; 测试输入字符，将其与小写字符 'z' 相比较
    ja Next                 ; 如果 ASCII 码值比 'z' 的 ASCII 码值大，则不是小写字符

    ; 此时我们拥有了一个小写字符
    sub byte [ebp+ecx],20H  ; 与 20H 相减，得到大写字符

Next:
    dec ecx                 ; 递减字符计数器
    jnz Scan                ; 如果仍然有字符，则继续循环


Write:
    mov eax,4               ; 指定 sys_write 调用
    mov ebx,1               ; 指定文件描述符1: 标准输出
    mov ecx,Buff            ; 传递缓冲区的偏移地址
    mov edx,esi             ; 传递缓冲区数据的#个字节
    int 80H                 ; 进行 sys_write 内核调用
    cmp eax,0
    jl WriteErrorMsg
    jmp Read                ; 回去继续循环，加载另一满满的缓冲区数据

; 输出读取错误信息 
ReadErrorMsg:
    mov eax,4		        ; 指定 sys_write 系统调用
	mov ebx,1 		        ; 指定文件描述符1：标准输出
    mov ecx,ReadError       ; 传递 ReadError 的地址
    mov edx,ReadErrorLen    ; 传递 ReadError 的长度
    int 80H
    jmp Done

WriteErrorMsg:
    mov eax,4		        ; 指定 sys_write 系统调用
	mov ebx,1 		        ; 指定文件描述符1：标准输出
    mov ecx,WriteError      ; 传递 WriteError 的地址
    mov edx,WriteErrorLen   ; 传递 WriteError 的长度
    int 80H
    jmp Done
    
    
; 全部搞定

Done:
    mov eax,1               ; 退出 syscall 的代码
    mov ebx,0               ; 将零作为返回值返回
    int 80H                 ; 进行 sys_exit 内核调用
```

