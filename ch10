# 第 10 章 分治 使用进程和宏来对抗程序的复杂性

复杂性是程序的致命之伤，这是我的血泪教训。它不仅对于汇编语言是正确的，而且适用于 Java, C, Pacall 或者曾经出现过的任何其他编程语言。现在，你已经能够编写相当复杂的汇编程序了，**你最好学会如何管理这种复杂性，否则你会发现自己不得不放弃大量代码，仅仅是因为记不起来或者无法推算出它的工作原理。**



## 10.1 盒子里面的盒子

在编程中，管理复杂性是一项非常巨大的挑战。其关键技巧听起来有点像东方神秘主义，但它实际上不过是一个来自生活的观察结果：任何行动的里面都包含着一个个更小的行动。

任何一个盒子的内容仅需一点点仔细研究就应该能被理解。每个单个的盒子不应该包含比较微妙或者较大块的内容，而且也不应该让人们花费几个小时的时间盯着它，绞尽脑汁才能推算出来。



### 10.1.1 作为代码盒子的过程

在编写软件期间，我本应该时刻注意那些共同工作以完成某一可识别任务的代码序列。当看到这样的序列时，我本应该把它们设置为过程，并为每一个过程赋予一个描述性名称。那样的话，每个序列就会拥有一个记忆标号以标示该序列的功能了。如果实现调整一行位置的操作使用了十条语句，那么这十条语句应该被命名为 JustifyLine，等等。

施乐公司的传奇 APL 程序员吉姆 邓恩后来高速我，APL 过程不应该编写得过长，以至于不能在一个 25 行的中断屏幕上显示完全。“如果超过 25 行，你在一个过程中所做的事情就太多了。所以，要把它分开”它说。从此以后，每当使用 APL 工作时，我都坚持那条睿智的经验规则。

所有当今常用的计算机语言都执行这种或那种形式的过程，汇编语言也不例外。一个汇编程序可能拥有许多个过程。事实上，对于可以在一个程序中包含多少个过程没有任何限制，只要所有过程包含的代码加在一起的字节总数，加上它们使用的数据，不超过 Linux 分配给单个用户空间程序的两千兆不断变化的字节即可。

那是很多的代码，即使是最大的商业应用程序，如 OpenOffice 也没有那么大。无论编写的汇编语言程序多么复杂，我们都可以通过过程来进行管理。





## 10.2 调用和返回

call 首先将它本身后面的下一条指令压入堆栈。 然后 call 将执行转移到 call 后面的标号处。最后通过 RET 而终止。RET 指令弹出堆栈顶部的地址，并将执行流程转移到该地址。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/call.png" alt="截屏2021-06-23 下午11.10.24" style="zoom:67%;" />



### 10.2.1 调用中的调用

在过程内部可以做任何主程序本身能够做的事情，包括从一个过程内部调用其他过程以及通过 INT 80H 调用请求 Linux 内核服务。



### 10.2.2 意外递归的危险

在一个过程内部调用另外一个过程时，需要注意至少一件事情：堆栈空间。每个过程调用都将一个 32 位的返回地址压入堆栈，只有当该过程的 RET 指令得到执行时，这个返回地址才会从堆栈中移除。**调用过深可能会使堆栈与数据或代码段相撞**。

递归是一种自己调用自己的技术，它是一种合法的表达方式。对于每一个对自身的调用，递归过程必须最终执行一个 RET 。何时返回通常由一个条件转移指令来控制，如果没有遵循该条件转移指令的使用规则，或者对其标志规范理解有误，就可能发生栈溢出，Linux 将提交一个分段错误。



### 10.2.3 一个需要堤防的标志规范 BUG

dec 并不影响标志位。在循环中，不能使用 dec 来控制循环变量。



### 10.2.4 过程及其所需数据

在汇编中，根据访问方法的不同，一般分为两种类型的数据:全局数据和局部数据。

全局数据：可被程序中任意位置的代码访问。全局数据项在 .data 段 和 .bss 段中进行定义。CPU 寄存器也可以作为全局数据的容器。

对于简单的程序而已，向一个过程传递数据的显而易见的方式就是将数据放在寄存器中。



### 10.2.5 保存主调程序的寄存器

CPU 寄存器很常用，但数量又很少。为了解决这个矛盾，可以在过程中，将处于空闲状态的压入栈中，然后就可以作为临时变量使用，在返回前再将它们以相反的顺序弹栈，这样它们就恢复了原来的值。这个过程称为寄存器保护。

例如:

```
push ebx
push esi
push edi
...
pop edi
pop esi
pop ebx
```

也可以一次性把所有寄存器保护起来，在过程中使用，前提是**不需要寄存器向主调程序返回任何内容**。

```
pushad
...
popad
```

如果该指令只在过程中执行次数很少，即使使用pushad也不会对整个程序产生可感知的影响。



主调程序中也可以保存自己的寄存器。原理和过程中寄存器保护类似。

```
push ebx
push edx
call CalcSpace
pop edx
pop ebx
```



关于寄存器的一些忠告：**保存任何你知道的既不在全局范围内使用，也不用来向主调程序返回任何值的寄存器。与由于寄存器冲突而造成的漏洞恶化相比，保存寄存器所需的时间是微不足道的。**



### 10.2.6 局部数据

如果一个过程拥有局部数据，那么当该过程被调用时，这些数据几乎总是存放在堆栈上。在通过 CALL 指令将数据传递给过程之前，主调程序使用 PUSH 指令将局部数据压入堆栈中。但这些局部数据，被调用的过程不能通过 POP 来访问，因为栈顶最后存放的是 CALL 指令之后的地址。

这些局部数据仍然可以通过存储器寻址和堆栈指针 ESP 来访问。但是在没有将返回地址弹出和重新压入堆栈之前，你不能使用 POP 指令来获取它们。但这不是明智的选择。**堆栈帧的概念将在本书的后面部分讲解。**出于安全使用考虑，局部数据需要一些特殊的照顾和纪律。



### 10.2.7 更多的表格技巧

可以由多个表组成一个功能更强大的表，如下列代码所示：

```asm
DumpLin: db " 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00"
DUMPLEN EQU $-DumpLin
ASCLin: db "|................|",10
ASCLEN EQU $-ASCLin
FULLLEN EQU $-DumpLin
```

这样可以单独处理表DumpLin 和 ASCLin，也可以将它们作为一个整体进行处理，如打印等。C 语言中的结构体在本质上也以相同的方式进行处理。



### 10.2.8 在过程定义中加入常量数据

```asm
; 可执行程序名：newlines
; 功能：发送1到15个换行符到 Linux 控制台
; 输入：EDX 1到15之间
; 返回值：没有
; 修改：没有，所有主调程序的寄存器都被保护
; 调用：sys_write
; 描述：通过使用 INT 80h sys_write，将若干个换行符(0AH)发送到标准输出；其中，换行符的个数由 EDX 中的值决定
; 本过程演示了将常量数据存放到过程定义本身，而不是放到.data 段或者 .bss 段

Newlines:
    pushad
    cmp edx,15
    ja .exit
    mov ecx,EOLs
    mov eax,4
    mov ebx,1
    int 80H

.exit:
    popad
    ret

EOLs: db 10,10,10,10,10,10,10,10,10,10,10,10,10,10,10
```

EOLs 表往往会随着Newlines过程一起被拷贝和剪切，因为EOLs只为Newlines所用。EOLs 表不是局部的，但是它"看起来"是局部的。



## 10.3 局部标号和跳转长度

什么是标号？

标号本质上是内存地址。

1. 可以表示过程，通过**跳转指令**可以将指令执行流程跳转到某个标号指定的地址处。将一个过程作为一个外部库让其他程序调用，也是通过将某个过程声明位 GLOBAL 来实现，
2. 可以表示变量，将某些变量作为一个外部库资源供其他程序使用，也是通过将某个变量标号声明为 GLOBAL 实现。

一个源程序可以包含很多标号，一个不可避免的问题就是标号重复的问题，这在跳转时会产生矛盾，到底跳转到哪个标号，为了解决这个矛盾，NASM 创造了一个特性：局部标号。

局部标号与普通标号的区别：

1. 局部标号以 '.' 开始，例如 .modTest
2. 局部标号的所属全局标号是指源代码文件中该局部标号上面的第一个标号。

```asm
; Go through the buffer and convert binary byte values to hex digits:
Scan:
	xor eax,eax		; Clear EAX to 0
	mov al,byte[Buff+ecx]	; Get a byte from the buffer into AL
	mov edx,esi		; Copy total counter into EDX
	and edx,0000000Fh	; Mask out lowest 4 bits of char counter
	call DumpChar		; Call the char poke procedure

; Bump the buffer pointer to the next character and see if buffer's done:
	inc esi			; Increment total chars processed counter
	inc ecx			; Increment buffer pointer
	cmp ecx,ebp		; Compare with # of chars in buffer
	jb .modTest		; If we've processed all chars in buffer...
	call LoadBuff		; ...go fill the buffer again
	cmp ebp,0		; If ebp=0, sys_read reached EOF on stdin
	jbe Done		; If we got EOF, we're done
```

上述代码中，局部标号 .modTest 所属的全局标号是 Scan

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-25 上午11.39.29.png" alt="截屏2021-06-25 上午11.39.29" style="zoom:67%;" />



关于局部标号的注意事项：

* 局部标号至少对于定义它们的过程而言是局部的。
* 局部标号不能作为断点供 Gdb 调试。
* 在一个全局标号下面，不要尝试定义太多局部标号。
* 一条经验法则：局部标号和到它们的所有跳转应该发生在一屏代码之内。
* 一个代码风格约定：将局部标号的句号之后的第一个字符采用小写形式。



### 10.3.1 “强行”访问局部标号

如何从外部访问某个局部标号？

例如: Calc 是一个全局标号，.modTest 是 Calc 的一个局部标号，通过如下代码从外部调用局部标号：

```
jne Calc.modTest
```



### 10.3.2 短转移，近转移和远转移

短转移：跳转的目标标号在 127 个字节以内的条件转移指令。

近转移：跳转目标的距离超过 127 个字节，但是仍然在当前代码段中的条件转移指令。(最大可跳转到距离该指令 2GB 的位置)。

远转移：跳转目标不在当前代码段。

```asm
jne Scan         ; 短转移指令
jne near Scan    ; 近转移指令
```



## 10.4 生成外部库的过程

从编译角度来看，每个单独的 .asm 文件都被认为是一个模块。不管是包含一个 _start: 标号，还是简单地包含过程。

每个可执行文件只能包含一个 _start: 标号。



### 10.4.1 全局声明和外部声明

当一个过程想从外部引用时：应该在 .text 段开头将该过程声明为 GLOBAL，例如：

```
GLOBAL MyProc
```



如果想在一个程序中使用外部库中的过程，那么必须使用 EXTERNAL 来声明该过程，表示该过程存在于外部库中。例如：

```
EXTERNAL MyProc
```



<img src="/Users/wangjun/Desktop/截图/截屏2021-06-25 下午3.44.13.png" alt="截屏2021-06-25 下午3.44.13" style="zoom:67%;" />

### 10.4.2 全局过程和外部过程的机制

* 外部模块不包含主程序，因此没有起始地址。
* 外部模块并不返回 Linux。



### 10.4.3 连接库文件到程序中

将库文件编译为 .o 文件，在连接的时候，需要包含所有需要的 .o 文件。例如：

```
hexdump3: hexdump3.o
	ld -m elf_i386 -o hexdump3 hexdump3.o ../textlib/textlib.o
hexdump3.o: hexdump3.asm
	nasm -f elf -g -F DWARF hexdump3.asm
```



### 10.4.4 太多过程和库的危险

过犹不及。



## 10.5 自定义过程的艺术

过程的作用：**将那些服务于公共目标的指令集合在一起，将其做成一个命名实体，因而使代码更加容易维护。**可维护性在软件设计中可能是块最难啃的骨头，而且可维护性完全取决于可理解性。



### 10.5.1 可维护性和可重用性

过程的一个最重要的目的：**通过用一个描述性的名称来代替一个机器指令序列来管理程序的复杂性。**其次是代码重用。

代码重用主要通过以下几种方式帮助我们实现代码的可维护性：

* 重用意味着较少的代码总量。
* 重用维护了你话费在调试方面的时间和精力。
* 重用迫使你一直在项目中保持一定的编码约定(因为你的库需要它)。
* 重用意味着你将拥有较少的，只是以稍微不同的方式完成相同的事情的代码序列。

总结下：**通过简单地减少必须管理的复杂性的数量来管理复杂性。**



### 10.5.2 确定哪些代码应该成为一个过程

什么时候一个指令块应该被做成一个过程呢？

* 寻找经常在一个程序内部发生的行为。
* 寻找可能不会在任何单个程序发生很多次，但却往往以相同的方式在许多或者大多数程序中发生的行为。
* 当程序变得越来越大，查找可被做成过程的功能模块，以便使主程序的整个执行流程变得更加容易理解。
* 在程序中寻找哪些为了响应不可控的力量(如数据规格，第三方库，等等)而可能随着时间变化的行为，并将这些行为隔离到过程中(方便后期修改)。
* 不过指令有多短小，可能只包含3条或4条，也可以做成一个过程。

```asm
Start: 
	Call initialize             ; 打开指定文件，创建缓冲区
	call OpenFile               ; 打开目标数据文件
	
Input: 
	call GetRec                 ; 从打开的文件中取出一条记录
	cmp eax,0                   ; 在文件读取过程中 测试 EOF
	je Done                     ; 如果我们已经碰到 EOF ，就关闭程序
	call ProcessRec             ; 处理该条数据
	call VerifyRec              ; 验证这条修改后的数据
	call WriteRec               ; 将修改后的记录写出到文件中
	jmp Input                   ; 转回去做重复的事情
	
Done:
	call CloseFile              ; 关闭打开的文件
	call CleanUp                ; 删除临时文件
	mov eax,1                   ; 指定退出系统调用
	mov ebx,[StatusCode]        ; 将状态码传递给操作系统
	int 80H                     ; 返回 Linux
```



### 10.15.3 使用注释标头

必须将每个单个单独过程相关的本质事实形成文档，否则你将很快忘记它们或者将它们记错并按照错误的信息采取行动。

我强烈建议在每一个自己编写的过程中增加一个注释标头，无论这个过程有多简单，这样的标头至少应该包含以下信息：

* 过程的名称。
* 最后修改日期。
* 每个入口点的名称，如果该过程拥有多个入口点的话。
* 过程所做的事情。
* 主调程序必须向其传递哪些数据它才能正常工作。
* 哪些数据(如果有的话)被该过程返回，以及这些数据被返回到哪个地方(例如，到寄存器 ECX 中)
* 过程修改了哪些寄存器或者数据项。
* 哪些其他过程被该过程调用(如果有的话)
* 在编写使用该过程的程序代码时需要牢记的所有注意事项。

除此之外，注释标头中的其他信息有时对我们也是有所帮助的：

* 过程的版本，如果使用版本控制的话。
* 过程的创建日期。
* 编写该过程的人的姓名

一个典型的可行的过程标头看起来像这样：

<img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-25 下午3.46.24.png" alt="截屏2021-06-25 下午3.46.24"  />



## 10.6 Linux 控制台下的简单关闭啊控制

可以通过将特定的字符编码发送的标准输出，来实现光标控制：

清空控制台： `ClearTerm: db 27,"[2J"    ; <ESC>[2J `
\<ESC\>的ASCII 码值为 27



将光标移动到指定位置：`PosTerm: db 27,"01;01H ; <ESC>[<Y>;<X>H`  

例如通过 C 实现光标控制：

```c
#include <stdio.h>
int main(){
    printf("%c%c%c%c",27,'[','2','J');   // 清空控制台
    printf("%c%c%c%c%c%c%c%c%s",27,'[','1','2',';','3','5','H',"hello world");
    printf("%c%c%c%c%c%c%c%c%s",27,'[','2','3',';','0','3','H',"Enter:");
    getchar();
    return 0;
}
```



### 控制台注意事项

基于 Debian 的 Linux 发行版中而设计的两种最流行的控制台终端实用程序——GNOME Terminal 和 Konsole上。

在 Konsole 中 通过 GreenBack: db 27,"[42m"    可以将控制台的背景色转换为绿色。

关于这方面的内容(以 简洁 Unix 风格)的资料可在 Linux 手册中根据关键字 "console_codes"找到，我鼓励你去尝试，同时铭记不同的控制台(特别是在非Linux的Unix实现上)可能对不同的转义序列有不同的反应。

不过，控制控制台的输出并不是最糟糕的。控制台编程的最高境界是创造全屏文本应用程序，它能够在控制台上"绘制"一个表格，包括数据入口字段，并允许用户通过使用 TAB键从一个字段跳转到另一个字段域，而且可在每个字段域中输入数据。这在 Linux 中极为困难，因为需要通过一些名为原始模式的方式访问控制台键盘上的单个按键。仅仅说明原始模式的工作原理就将花费一章的大部分篇幅，而且会涉及很多我在本书没有空间讲解的比较先进的 Linux 话题。

处理控制台的标准 UNIX 方式是一个名为一个 ncurses 的 c 库并且虽然 ncurses 可以从汇编中进行调用，但是它实际上是一个既臃肿又丑陋的家伙。汇编程序员的更好的选择是一个比较新的，专门为 NASM 汇编语言而编写的库，名为 LinuxAsmTools。它的作者是杰夫-欧文斯，它几乎能做所有ncurses 能做的事情，而且没有 c 的硬性约定和令人讨厌的东西。LinuxAsmTools 是免费的，可以在 http://linuxasmtools.net/上找到它



## 10.7 创建和使用宏

![截屏2021-06-25 下午5.39.11](/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-06-25 下午5.39.11.png)



### 10.7.1 宏定义机制

 ; macroName 为宏名，n 为调用宏时必须传入的参数个数，参数在宏中通过使用%1，%2...%n来引用。

%MACRO macroName n     

...

%ENDMACRO



### 10.7.2 定义带参数的宏

观察下列宏

```
%macro WriteCtr 3	; %1 = row; %2 = String addr; %3 = String length
	push ebx	; Save caller's EBX
	push edx	; Save caller's EDX
	mov edx,%3	; Load string length into EDX
	xor ebx,ebx	; Zero EBX
	mov bl,SCRWIDTH	; Load the screen width value to BL
	sub bl,dl	; Calc diff. of screen width and string length
	shr bl,1	; Divide difference by two for X value
	GotoXY bl,%1	; Position the cursor for display
	WriteStr %2,%3	; Write the string to the console
	pop edx		; Restore caller's EDX
	pop ebx		; Restore caller's EBX
%endmacro
```



宏 WriteCtr 需要3个参数，这个 3 个参数分别在宏体中用 %1 %2 %3按传入顺序依次表示。



### 10.7.3 宏调用机制

以下是对 WriteCtr 宏的完全合法且合理的调用方法：

```
mov al,4
WriteCtr al,AdMsg,ADLEN
```

在 WriteCtr 中，在 NASM 用 AL 寄存器的名字取代了 %1 形参，所以：

```
GotoXY bl,%1   ; 定位贯标用于显示指定内容
```

变成了

```
GotoXY bl,al
```



类似地，可以将一个带括号的地址作为实参来传递

WriteCtr [RowValue],AdMsg,ADLEN

此时 %1 就表示地址，使用时需要指定条件限定符:byte,word ,dword



### 10.7.4 宏内部的局部标号

在宏定义内部的所有标号都被认为是宏的局部标号，并且被汇编编译器进行了特殊处理。

在宏内部定义的局部标号名称以 "%%" 开头

例如 

```
%%IsLC:
	cmp byte [edx+ecx-1],'z'
	....
	sub byte [edx+ecx-1],20H
```

需要引用时：

```
 jmp %%IsLC
```

在编译器编译的时候，NASM 会将宏内部的局部标号名称生成一个独一无二的名称(以..@为前缀，将一个4位数字和标号的名称相连)，防止不管宏被调用多少次都不会出现同名的标号。例如：

%%IsLC 标号，在一次给定的调用中，可能会成为 ..@1771.IsLC



### 10.7.5 像包含文件一样宏库文件

宏库文件 以 mac 作为扩展，例如：mylib.mac

在需要使用该宏的文件中，需要在程序中包含，例如：在 .text 段的开头包含 `%include "mylib.mac"`

如果宏库文件不在当前目录下，那就必须包含宏库文件的完整路径。



### 10.7.6 宏 vs 过程：优点和缺点

宏：

* 优点：执行速度快
* 缺点：占用更多内存空间

过程：

* 优点：占用空间少
* 缺点：执行速度慢：执行和控制进入一个过程的 CALL 指令和从一个过程中退出均需要时间。而在一个宏中，这两条指令一个也不使用。

