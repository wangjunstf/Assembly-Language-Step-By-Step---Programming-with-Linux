# 第 5 章 汇编的权利 汇编语言程序的创建过程

汇编语言的组织方式与C，Java或者 Pascal 的组织方式不同。最明显的区别是，不能通过试验和错误来编写汇编语言程序。



## 5.1 文件及其包含的内容

所有编程过程都是处理文件的过程。有些编程方法隐藏了其中一些文件，所有方法在一定程度上都是为了让人类更加容易地了解这些文件里面的内容，但底线是你要创建文件，处理文件，阅读文件和执行文件。



对于汇编语言，文件在我们面前什么都没隐藏，要想学好它，你必须愿意进入你所处理的任何文件的内部，通常在字节，更多的是在位的层面去理解它。者需要更长的时间，但是它会给你带来巨大的知识回报：**你将知道一切是怎么工作的**。



### 5.1.1 二进制文件 VS 文本文件

文本文件(text file)是指可以在文本编辑器(如记事本)中打开并能进行有意义地检查的文件。

二进制文件(binary file)是指包含不能显示为有意义的文本的值的文件。



从某一高度来看，汇编语言(或许多其他语言)编程的过程包括采用人类可读的文本文件，以某种方式将它们转化为含有 CPU 能够理解的二进制指令序列。

作为程序员，还需了解哪些文件代表哪些机器指令，以及每个机器指令是如何被处理的。你还需能够“打开”一个可执行的二进制文件并检查它所包含的二进制值。



### 5.1.2 用 Bless 编辑器查看文件内容

左边一栏是偏移列：它包含显示在中间一栏里的那一行的第一个字节与文件开头的第一个字节的偏移量。

最右一栏：用可视化的文本字符以文本形式显示同一行数据。



\r\n 的历史：

在电传打印机时代，有两个单独的电命令被内置到电传机中，当答应文档时，用它们来处理文本行的结束。一个命令用于索引文件的下一行，另一个命令用于返回到左边距处的打印开始处。它们被称为回车(0DH)和换行(0AH)。大多数计算机系统和软件现在忽略回车码，但是也有少数(如记事本)仍然需要它来正确显示文本文件。



0AH 是一个非常好的 EOL(行结束)标记。



### 5.1.3 解释原始数据

在文本文件中，二进制:01010011表示大写字母"S"，在一个二进制可执行文件中，位模式 01010011 可能意味着完全不同的内容，这取决于它刚好位于文件中的位置，以及在该文件中，它的附近存在着哪些其他位模式。



### 5.1.4 字节序

假设内存中存在这样一段位数据(16进制表示): 5361，因为该数据占用两个字节，用不同的字节序有不同的解释。

53为最高有效字节，61为最低有效字节。

我们规定：

多字节值的最高有效字节的的偏移量最小，最低有效字节的偏移量最大，称为**大端序**

多字节值的最高有效字节的偏移量最大，最低有效字节的偏移量最小，称为**小端序**

如下图所示：

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-08%20%E4%B8%8B%E5%8D%883.40.09.png" alt="截屏2021-06-08 下午3.40.09" style="zoom: 67%;" />





字节序不同，对多字节数据的解释就不同，因此必须明确自己系统中所用的字节序。图5-6 显示了采用不同字节序计算一个 32 位值的区别。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-08%20%E4%B8%8B%E5%8D%883.45.20.png" alt="截屏2021-06-08 下午3.45.20" style="zoom:67%;" />



## 5.2 文本进去，代码出来

从某一高度来看，所有程序都归结为文件处理。其目标是采用一个或多个人类可读的文本文件，然后对其进行处理，创建一个可执行程序文件。

程序翻译器(program translator)是生成 CPU 可以理解的机器指令的翻译过程。程序翻译器一行一行地读入源代码文件，并写出一个完成源代码文件所描述的计算机操作的二进制机器指令文件。这种二进制文件称为目标代码文件(object code file)。

编译器(compiler)是一种程序翻译器，它读入采用高级语言(如 C 或 Pascal)编写的源代码文件，并写出目标代码文件。

汇编编译器(assembler)是一种专用编译器。它也是一种程序翻译器，用于读取源代码文件并将其输出为供 CPU 执行的目标代码文件。但是，汇编编译器专门设计用来把汇编语言翻译成目标代码。语言编译器(如 Pascal 或 C++编译器)将源代码文件编译为目标代码文件，采用类似的描述，我们说，汇编语言编译器将汇编语言源代码文件编译为目标代码文件。

汇编语言具有非常重要的特征，也正是这一点，使它在众多编译器中与众不同，即：完全控制目标代码。



### 5.2.1 汇编语言

有些人把汇编语言定义为一种语言，在这种语言中，一行源代码生成一条机器指令。但绝不能按照字面意义去理解，因为汇编语言源代码文件中的某些行是翻译器程序(而不是 CPU)的指令，根本不产生机器指令。



#### 汇编语言定义：

汇编语言(assembly language)是一种翻译器语言，它运行完全控制有翻译器程序生成的每一条机器指令。这种翻译器程序称为汇编编译器。

高级语言，例如Pascal对每一条语句，例如`I := 42;`可能翻译为四五条机器指令，这些指令获取字面数字值 42，将其存储在名称 I 编码的内存位置。通常情况下，Pascal 程序员根本不知道那四五条指令实际是什么，也完全没有办法改变它们，即便知道一个比编译器使用的机器指令序列更快速和更高效的指令序列，除了接受 Pascal 编译器生成的机器指令，别无选择。



#### 在高级语言中使用汇编：

现代的高级语言编译器通常采用所谓的行内汇编(in-line assembly)，它允许程序员从编译器“收回”控制器，“插入”一系列他或她自己设计的机器指令。在使用行内汇编之前，你必须了解编译器如何生成自己的代码(并且在没有进行大量的学习研究和实践之前，不要想很多人那样，想当然认为自己能够比编译器做得更好)



CPU 有很多机器指令，其中每一条都有一个对应的汇编语言助记符。助记符的目的就是为了帮助程序员记住二进制机器指令。例如能够实现将标志寄存器压入堆栈的二进制机器指令是 9CH， 它的助记符是 PUSHF，这比记忆9CH 容易多了。



编写汇编语言源代码文件实际上是在组织一系列助记符，通常情况下，在源代码文本文件中每行放一个助记符，一个源代码文件中的部分内容可能是这样的：

```asm
mov eax,4                      ; 04H 指定系统写内核调用
mov ebx,1                      ; 01H 指定标准输出
mov ecx,Message                ; 把要显示的字符串的起始地址加载到 ECX 中
mov edx,MessageLength          ; 把要显示的字符串的字符个数加载到 EDX 中
int 80H;                       ; 进行内核调用
```

上述代码中，左边距处的 MOV 是助记符。紧挨着每一个助记符的数组和文本叫做操作数。 各种个样的机器指令拥有各种各样的操作数，也有一些指令(如前面所述的 PUSHF)根本不使用操作数。

助记符和它的操作数合在一起称为指令(instruction)。(分号右侧的语句是注释，它们不是指令的组成部分)。如果特别谈论二进制代码，通常称为机器指令。

汇编编译器最重要的工作是从源代码中读出一行行语句并将机器指令写出到目标代码文件。如下图：

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-08%20%E4%B8%8B%E5%8D%884.43.10.png" alt="截屏2021-06-08 下午4.43.10"  />



### 5.2.2 注释

每条指令的右侧是以分号开始的文本。该文本叫注释，其目的显而易见：解释相关汇编语言指令的作用。

在结构上，注释始于一行的第一个分号，一直持续到标示该行行尾的EOL。注释块也很简单，它的每一行都以左边距处的分号为开始。

#### 汇编编程建议

注释对于汇编语言程序的成功而言至关重要，其重要性远远超过任何一种其他编程语言。我的个人建议是：源代码中的每一条指令都应该有关于其功能及作用的相应注释。此外，在每组以某种方式共同工作的指令前面，都应该有一个注释块，从某一高度解释这组指令，以及它们如何协同工作。

注释对于理解文本文件非常重要。

简而言之：注释开始于分号，结束于EOL。



### 5.2.3 当心 “只写” 源代码

汇编语言中有一种非常严重的问题。汇编指令本身非常简洁，以至于任何有用的事情都需要许多条指令才能完成。除此之外，尽管每条指令声明了它所做的事情，但是并没有任何内容表明该条指令操作的上下文环境。在 Pascal 或者 Basic 代码中，可以通过一些技巧和规则(以及一些见名知意的标识符)构建上下文环境，但是在汇编语言中，只能通过注释来添加上下文环境。



编写汇编语言程序需要投入大量的时间和精力——远远超过在那些“一半天堂”的语言(如 C 和 C++)，并且匪夷所思地超过那些“什么都替你做了”的IDE集成环境(如 Delphi，Lazarus 和 Gambas)。汇编语言程序的编写方式比任何一种其他语言程序的编写方式都困难；如果不添加注释，你很可能最终只能丢弃令人费解的数百行代码，从头开始，再编写一遍。



**聪明地工作。不停地写注释，直到退出**



### 5.2.4 目标代码和连接器

汇编器读入源代码文件，并生成包含 CPU 能够理解的机器指令以及所有在源代码定义的数据的目标代码文件。这样的一步到位汇编并没有什么真正的价值，除非你刚刚开始学习汇编语言。

因此，现代汇编编译器产生的目标代码文件是一种源代码文件和可执行文件之间的中间步骤。这个中间步骤是一种类型的二进制文件，叫做目标模块(object module)，或只是一个简单的目标代码文件。

目标代码文件本身并不能作为程序运行。想要把目标代码变成可执行程序文件，还需要一个额外的必要步骤，那就是连接(link)。

目标代码文件作为中间步骤的原因是：大的源代码文件可以划分为许多更小的源代码文件，以保持文件大小和复杂性的可管理性。汇编编译器单独汇编各种各样的片段，然后将生成的目标代码文件交织在一起，组成一个可执行程序文件。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/assembler1234.png" alt="assembler" style="zoom:67%;" />

连接器不只是把目标代码组合成一个单个的块。它确保模块以外的函数调用能够到达目标对象模块，并且确保所有此类内存引用实际上指向它们期望引用的地方。汇编编译器的工作是显而易见的；连接器的工作是微妙的。两者对于产生一个已完成的，能够工作的可执行文件来说，都是必不可少的。



开始将程序中经常使用的部分提取到自己的个人代码库，这样做有两个原因。

1. 可以把已通过测试和验证的程序放到单独的库文件中，将其连接到任何可能需要它们的程序中。这样就可以重用代码，而不是每一次都重蹈覆辙，重新开始一个新的汇编语言编程项目。
2. 一旦一个程序的部分内容已经通过测试，并且发现是正确的，就没有必要浪费时间让它们随较新的，未经测试的程序部分一起，一遍又一遍地重新编译。一旦一个主要程序增长到成千上万行代码(这一时刻可能会比你预想的更快到达！)，通过只编译当前正在工作的那部分程序，然后将已完成部分连接到最终程序，不必每次重新编译整个程序的每一个组成部分，可以节省大量的时间。



连接器的工作复杂，而且不容易描述。每个目标模块可能包含以下内容：

* 程序代码，包括已命名过程。
* 对外部模块中存放的已命名过程的引用。
* 已命名数据对象: 具有预定义值的数字和字符串。
* 为程序以后使用的预留的，只是空白空间的已命名数据对象。
* 对存放在模块外部的数据对象的引用。
* 调试信息。
* 一些用来帮助连接器创建可执行文件的其他不太常见的杂项。



要想将若干个目标模块处理成一个单个的可执行模块，连接器必须首先建立一个索引，这个索引叫做符号表(symbol table)，里面存放的是它连接的每一个目标模块中的每一个已命名项，其中存放着一些关于哪个名字(叫做符号)指向模块内部哪个位置的信息。一旦符号表完成后，连接器将生成一个映像，里面存放着当操作系统加载它时，如何将可执行文件安排在内存中的相关信息。然后，该印象被作为可执行文件写入磁盘。

关于映像，最重要的事情是：连接器生成相关的地址。一个目标模块允许引用其他目标模块中的符号。在汇编过程中，这些外部引用(external reference)被作为“小洞”预留下来，以后再填补——顺理成章，因为这些外部符号存在的模块可能还没有编译，甚至还没有编写。当连接器生成一个最终可执行程序文件的映像时，它知道所有这些符号位于该映像的什么地方，从而可以把所有的实际地址放入那些外部引用“小洞”。

调试信息可以让程序员在调试时更容易看到数据项的名字。

一旦程序制作完成，并完全通过调试，再一次在不带调试信息的情况下重新运行汇编编译器和连接器。因为调试信息可以让可执行文件大很多，而且运行速度会变慢一些。



### 5.2.5 重定位能力

最早期的计算机系(如运行 CP/M-80的 8080 系统)的内存地址体系结构非常简单。程序也被设计为加载并运行在一个特定的物理内存地址。对上述系统，对程序员而言任何程序都将从100H开始，然后从那里往后延伸。

随着 8086 及其特头的操作系统的到来(如 CP/M-86 和 pc DOS)，一切都发生了变化。与 8086 一同引入的 Intel 体系结构内部有了很大的改进，从而使程序无需被编译为在特定的物理地址运行。可执行文件内部的所有引用都是通过相对于该程序起始位置的偏移量来指定。偏移量总是相同的，并且因为所有的引用都是相对于可执行程序文件的起始位置，所以，在运行时，程序存放在物理内存中的什么地方都没有关系。

这种特性叫可重定位能力，它是所有现代化计算机系统的必要组成部分，特别是当多个程序可以同时运行时。处理重定位也许是连接器的最主要工作。

幸运的是，它自己能够完成此项工作，并不需要任何来自外界的输入。一旦任务完成且善后工作处理完毕，文件翻译工作就彻底完成，你将得到一个可执行程序。



## 5.3 汇编语言的开发过程

在编写，编译，测试汇编语言程序的过程中，包含很多种不同类型的文件和相当多的程序。可以用下图描述这个过程。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-08%20%E4%B8%8B%E5%8D%8810.19.26.png" alt="截屏2021-06-08 下午10.19.26" style="zoom:67%;" />



概括讲，这个过程可归结为如下内容：

(1) 在文本编辑器中创建汇编语言源代码文件。

(2) 用汇编编译器从源代码文件创建目标模块。

(3) 使用连接器把目标模块(和任何以前编译的，也是该项目的一部分的目标模块)转换为单个的可执行文件。

(4) 通过运行程序文件来对其进行测试，如果有必要，可以使用调试器。

(5) 回到步骤(1)中的文本编辑器，修复以前可能犯下的任何错误，并在必要时编写新的代码。

(6) 重复步骤(1)到(5)，直到完成。



### 5.3.1 工作目录规范

程序员通常从 0 开始计数，如果对汇编语言开发过程的步骤进行计数的话，步骤0包含的内容为：在Linux 电脑上建立一个系统目录，以管理在该过程中创建和处理的文件。

一个项目只能存储于一个目录之下。也就是说，当你想编写一个名为 TextCaser 的Linux 程序时，创建一个名为 TextCaser 的目录，并保持在该目录中只保存与 TextCaser 项目直接相关的文件。如果你有另一个名为 TabExploder 的项目，应该为其单独创建一个自己的目录。首先，这是一种非常好的管理实践，其次，它能有效防止将生成文件(makefile)搞乱。

我建议为汇编开发项目建立一个目录架构，我的经验建议这样做：在 Linux Home 目录下创建一个名为 “asmwork” 的目录，并创建一个以个人项目命名的目录作为整个汇编语言目录的子目录。

顺便说下，一个目录的名称可以与该项目的主.ASM 文件相同：也就是说，textcaser.asm 非常乐意在名为 textcaser 的目录下。



### 5.3.2 编辑源代码文件

汇编语言源代码文件以 .asm 为文件扩展名保存在磁盘上。



### 5.3.3 编译源代码文件

文本编辑器生成一个 .ASM 为扩展名的源文件，然后这个文件被传给汇编编译器本身，以将其解释为一个目标模块文件。在本书的环境——Linux 和 在 NASM汇编编译器下，文件的扩展名为 .O



当读取源代码文件中的代码行时，汇编编译器会对它们加以检查，建立一个符号表来总结源代码文件中的每一个已命名项，构建源代码行所代表的二进制机器指令，然后把这些机器指令和符号信息写入目标模块文件。当汇编编译器完成并关闭目标模块文件时，它的工作完成，他将终止运行。在现代 PC 上，对于一个不到 500 行代码的程序而言，这些事情的发生只需 1 秒或更少的时间。



### 5.3.4 汇编错误

如果汇编编译器从源代码中读取一行代码时，汇编编译器遇到一些不能理解的事情，这个不被理解的文本叫错误(error)，汇编编译器会显示一个错误信息(error message)。

例如：

当遇到 `mov eax,evx`时，NASM将显示如下错误信息:"testerr.asm:20 symbol 'evx' undefined"

当遇到 `mov ax,ebx`时，NASM将显示"testerr.asm:22: invalid combination of opcode and operands"。对于该错误，汇编器没有给出更详细的信息，你必须知道什么是合法的，什么是非法的，才能真正理解做错了什么。

汇编错误信息并不能把你从理解 CPU 或汇编编译器规则的责任免除。

从第一次坐下来编写自己的汇编代码开始，这些会变得越来越清晰，对于更加深奥的错误，汇编器提供的错误信息几乎毫无帮助价值。

如果已经显示了大量的出错信息，汇编程序将终止。从第一个错误开始，一定要了解它(做笔记)，然后继续下去。如果第一个错误之后的错误不符合逻辑，那么修复第一个或前两个错误，然后再重新编译。



### 5.3.5 回到编辑器

修复错误的方法是把有问题的源代码文件加载回文本编辑器，然后开始仔细寻找错误。

汇编错误信息几乎总是包含一个行号。将光标移动到那个行，开始寻找错误和那些不切实际的幻想。如果立即发现了错误，马上修复它，然后继续寻找下一个。



### 5.3.6 汇编警告

汇编时警告是汇编编译器作为有经验的顾问，向你暗示在源代码中有些东西有点冒险。这些东西并不严重得足以引起汇编编译器停止汇编文件，但是它的严重程度足以让你注意并展开调查。例如，如果你定义了一个命名标签，但是没有在后面放置任何指令，NASM 会显示一个警告，但这可能不是错误，而是你的疏漏，你应该密切关注该行并努力回想你在编写它时究竟在想什么。



如果你是普通的初学者，百分百做出本书列举的每一件事情，你应该“嚼烂”汇编参考手册，弄明白为什么汇编编译器会对你发出指责的滋滋声。无视警告可能会在后来的程序测试中导致奇怪的错误。或者。忽略警告消息可能根本没有任何不良后果。但是我认为，知道发生了什么事情总是更好些。请遵循这条规则：

**只有当确切知道汇编警告意味着什么时才可以忽略警告消息**

否则，必须将它像一个错误信息一样对待。只有完全理解它的根源及其含义之后，你才可以尝试做出决定：是忽略还是不忽略它。

总之，汇编语言开发过程的第一部分(如图 5-9)是一个循环。

如果没有进一步发现错误，汇编编译器将一个.O 文件写到磁盘中，可以准备进行下一个步骤了。



### 5.3.7 连接目标代码文件

连接步骤显示在图5-9的右半边。右上角是一排.O 文件，这些 .O文件是以前编译的正确的 .ASM 文件，它们包含机器指令和数据对象的目标模块文件。当连接器(linker)连接由正在处理中的 .ASM 文件所产生的 .O 文件时，它将这些以前编译的.O 文件加入其中。连接器写入磁盘的单个可执行文件包含来自所有当它被调用时传递给它的.O 文件的机器指令和数据项。

一个非常重要的好处，一些.O 模块中的过程可以被用于将来的，甚至还没有开始的汇编语言程序中。创建这样的“工具”程序库是通过重用代码节省时间的一个非常有效的方法，甚至不需要再把它传给汇编编译器。

Linux 拥有自己的连接器，叫ld。

本书比较简单的程序将使用 ld，但是到了第 12 章，我们将接纳 Linux 的特点，使用一个C编译器作为连接器。



### 5.3.8 连接错误

连接错误比汇编错误更微妙一些，它们通常很难找到。幸运的是，它们比较少见，而且不容易发生。正如汇编错误一样，连接错误是致命的，它们使可执行文件无法生成；当连接器遇到错误时，它将立即终止。当你遇到连接错误时，必须返回到编辑器，找出问题所在。一旦识别出问题(或者认为已经识别出)，对源代码文件进行一些修改以修复它，你必须重新编译该程序，然后重新连接以查看连接错误是否已经消失。直到连接错误不复存在。

如果可能，尽可能通过试验和错误来避免这种情况的发生。阅读汇编编译器和连接器文档。了解你正在做什么。对在汇编器和连接器中发生的事情越了解，就越容易确定哪些东西适合连接器。



### 5.3.9 测试 .EXE 文件

如果没有收到连接错误，连接器将创建一个单独的可执行文件，该文件包含出现在连接器命令中的所有文件中的机器指令和数据项。这个可执行文件就是你的程序。

在 Linux 下，一个调用程序的命令行可能是这样的：

./myprogram

这是快乐真正开始的时候。



### 5.3.10 错误 VS 漏洞

漏洞是指任何不按照你的意图去工作。这使得漏洞比错误(error)更加主观。

“漏洞对决特性”冲突应由你来负责。你对程序应该做什么以及怎么做应该有一个相当清楚的构想，并且应该将其备份为一套书面规范或者其他某种类型的文档，那就是判断 bug 的标准。

以下是一个常见的提示: "Segmentation Fault"，它被称为运行时错误(runtime error)。通常情况下，你的程序不会激怒操作系统。它只是不会做你期望它做的事情，而且很可能在失败的过程中没有说出太多内容。

幸运的是，Linux 是一个坚固的操作系统，它考虑到了充满漏洞的程序，“程序打败机器”这种情况及不可能像在DOS 时代那样常见。

为了阻止这种 Babel 效应，我认为最重要的事情是要认真地划清错误和 bug 之间的区别。错误是源代码文件中的某些错误的东西，被汇编编译器或者连接器认为不可接受而踢出来。错误阻止编译过程或者连接过程继续进行，进而阻止生成最后的 .EXE 文件。

bug 则是在程序执行中发现的问题。它既没有被汇编编译器察觉，也没有被连接器发现。bug 也可以是良性的，例如在屏幕信息中拼错的单词，或在显示器定错位的行; bug 也可以迫使程序提早终止。如果程序试图执行某些禁止的事情，Linux将终止它，并显示出错信息。这些错误被称为运行时错误，但它们实际上是漏洞造成的。

错误和 bug 都要求你返回文本编辑器编辑并修改源代码文件中的一些内容。所不同的是，大多数错误被报告出来，用一个行号指出你应该查看源代码的什么地方来修复该问题。相反地， bug 则被遗留下来供新手们联系。你必须寻找它们，无论是汇编编译器，还是连接器，都不会为你提供多少线索。



### 5.3.11 我们还在那里吗

图 5-9 表明，如果程序工作完美的话，汇编语言开发过程就可以宣告结束了。一个非常严肃的问题：你如何知道它何时工作完美？在学习语言过程中编译的一些简单程序可能很容易在一两分钟之内测试完毕；但是任何一个能够完成某些有用事情的程序都将花费至少数小时的测试时间。一个重要的大型应用可能花费数周或者数月才能进行彻底的测试。对于采用各种各样的输入值且产生各种各样的输出值的程序，要使用输出值的尽可能多的不同组合来进行测试，每次应该检查每一个可能的输出。

即便如此，在较大的程序中找到一个漏洞仍然被有些人认为是遥不可及的理想。也许——但是你应该以一种你可以做到的尽可能高效的方式，争取尽可能地接近这一理想。



### 5.3.12 调试器和调试

汇编语言开发过程中的最后一个，也绝对是最痛苦的组成部分是调试。调试(debugging)是简单的系统过程，我们通过这一过程来定位和纠正 bug。调试器(debugger)是一种实用工具，专门设计用于帮助你定位和识别 bug。

在所有种类的软件中，调试器是最神秘，最难以理解的。调试器与程序一起，加载到内存中，并与程序一起，一直在内存中。然后调试器转到程序中，完成一些真正独特的事情。

调试器能够让你一次执行程序中的一条机器指令，这样你就可以在每两条指令之间无期限等待，以检查上一条指令的指令执行效果。调试还允许你在两条指令之间的暂停期间，查看程序运行访问的内存块中的任何位置的内容以及存放在任何 CPU 寄存器中的值。

调试器能够做这些神秘的事情，因为它们是必不可少的，CPU 拥有一些内置到其硅芯片中的特殊属性，这些属性使调试器成为可能。它非常令人着迷，我建议你在熟悉了 x86 CPU 的内部结构之后，进行进一步的研究。

一些调试器能够同时显示机器指令和源代码，这样就可以看到哪些源代码文件对应哪些二进制代码。还有一些其他调试器能够根据名字而不是通过内存地址来定位一个变量。

DOS 和早期版本的 windows 所配备的调试器是 DEBUG

Linux 有一个非常强大的调试器，教 gdb



## 5.4 沿着汇编小路旅行

我们确实还在那里，同时，你必须理解汇编语言的开发过程，否则，即便知道指令如何工作也不会对你有丝毫的帮助。



#### 5.4.1 安装软件

Linux 下的非预装软件通过使用软件包管理器(package manager)得到。软件包管理器是个人电脑上的一个目录程序，用于维护 Linux 下所有可用的免费软件包列表。你可以选择你想要的一款软件，软件包管理器会上网，从它们的在线主页(名为知识库)中下载它们， 然后再为你安装它们。

在Ubuntu Linux 操作系统下安装了两款软件包管理器。

*  Application 菜单中看到的 Gnome Application Installer，它作为添加/删除菜单项而出现。这款软件包管理器由于其简单性而出现在那里，但是，它没有列出每一个你可能想要的免费软件包。
*  藏身于 System -> Administraton 菜单的是 Synaptic Package Manager，它可以(至少在理论上)访问任何一个已经被提交到公共知识库的免费软件产品。

在 Linux 下，不必担心软件被安装到何处。几乎所有的软件都安装在/usr 目录层次结构下。

我们需要很多开发工具：一个编辑器，一个汇编编译器，一个连接器和一个调试器

Linux 下安装Synaptic Package Manager包管理器

```shell
sudo apt update
sudo apt install synaptic
```



### 5.4.2 第 1 步: 在编辑器中编辑程序

```asm
; 可执行程序明 : EATSYSCALL
; 版本 : 1.0
; 创建日期 : 2021-1-9
; 作者 : 王俊
; 描述 : 一个简单的 Linux 下的汇编应用程序，使用  NASM 2.13.02
;   演示了  Linux INT 80H  系统调用显示文本的用法
;
; 使用这些命令生成：
; nasm -f elf -g -F stabs eatsyscall.asm
; ld -o eatsyscall eatsyscall.o
;

SECTION .data                   ; 包含已初始化的数据的段


EatMsg: db "Eat at Joe's!",10
EatLen: equ $-EatMsg

SECTION .bss                    ; 包含未初始化的数据的段
SECTION .text		        ; 包含代码的段

global _start                   ; 连接器需要据此找到入口点！

_start:
	nop			    ; 这个无操作指令让 gdb 非常高兴
	mov eax,4		; 指定 sys_write 系统调用
	mov ebx,1 		; 指定文件描述符1：标准输出
	mov ecx, EatMsg	        ; 传递显示信息的偏移地址
	mov edx,EatLen 		; 传递显示信息的长度
	int 80H			; 进行系统调用来输出文本到标准输出
	mov eax,1 		; 指定 Exit 系统调用
	mov ebx,0		; 返回一个零代码
	int 80H			; 进行系统调用来终止代码
```



### 5.4.3 第2步 使用NASM 编译程序

编译命令：

```shell
$ nasm -f elf -g -F stabs eatsyscall.asm
```

`-f elf`有许多种有用的目标文件格式，而且每一种都以不同的方式生成。NASM 汇编器能够产生其中的大多数，包括其他格式，如 bin, aout, coff和ELF64，你可能不需要它们，至少暂时不需要。-f 命令告诉NASM ，它将对目标代码文件采用哪种格式。在 32 位 IA-32 Linux 工作环境下，命令格式为 ELF32，它可以在命令行中通过简单的elf来指定。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-09%20%E4%B8%8B%E5%8D%883.06.06.png" alt="截屏2021-06-09 下午3.06.06" style="zoom:50%;" />



-g 将调试信息嵌入目标代码文件，以便使用调试器来定位出现问题的地方。

-F stabs 与输出文件一样，NASM 也可以采用不同的格式生成调试信息，如果你工作于 IA-32 Linux 下，很可能为调试信息使用 stabs 格式，至少在你刚刚开始学习汇编时。还有一种更为强大的调试格式，叫 DWARF，也可以与elf 一起使用。

可以使用 -o 选项指定生成的目标文件文件名，例如：下述命令将生成syscall.o

```shell
$ nasm -f elf -g -F DWARF eatsyscall.asm -o syscall.o
```



### 5.4.4 第 3 步：使用 LD 连接器

```shell
$ ld -m elf_i386 -o eatsyscall eatsyscall.o
```

ld : 调用连接器

-m elf_i386 指定生成的软件架构，必须与eatsyscall.o的架构对应。

-o eatsyscall 指定即将产生的可执行文件的名称

eatsyscall.o  指定即将链接的目标代码文件的名称

当使用了其他代码库时，必须在输入命令行中输入正在使用的每一个库的名字。



### 5.4.5 第 4 步：测试可执行文件

一旦链接器无错通过，已经完成的可执行将在工作目录下等着你。如果汇编编译器和连接器消化了它，且没有显示任何错误信息，表明它没有错误。然而，没有错误并不代表没有缺席。为了确保其工作，只需在终端上命令行指出其文件名运行。

```shell
$ ./eatsyscall 
Eat at Joe's!
```



### 5.4.6 第 5 步：在调试器中观察程序运行

大多数时候，编写完程序需要立即开始查找漏洞。为此，最简单的方法是将可执行文件加载到调试器中，以便单步处理，在每条机器指令执行完毕之后，暂停一下，看看每条指令对寄存器和内存中定义的每一个变量有什么影响。gdb 和 KDbg两个程序一起，提供了一个愉快的(可以忍受的)调试经历。gdb 实用程序完成调试器所做的纵深层次的 CPU  魔术，而 KDbg 则在显示器上将其排列整齐，并允许你控制它。

要想启动一个调试会话，从终端窗口命令行中调用 KDbg，后面跟上可执行文件的名称：

kdbg eatsyscall



kdbg 官网：

https://www.kdbg.org/manual/howdoi.html



`INT 80H`指令是一个特殊的指令。它生成一个名为 sys_wait的 Linux 系统调用(我们亲切地称之为syscall)，它将数据发送到当前活动的终端窗口。

将 EatMsg 发送到输出窗口，这就是 eatsyscall 程序的设计初衷。它的任务完成后，程序中的最后三条指令主要做一些整理工作，然后结束。务必使 EAX 与 EBX 在最后的 INT 80H 前接收到新值，这些新值向 Linux 发出信号，告诉它该程序已经完成。

Step Into By Instruction 按钮指明 一步一步地通过一个过程。

Step Over By Instruction 按钮指明 不进入方法调用，停在方法调用之后的指令处。



在基于 IA-32 的保护模式下，像 EatMsg 这样的数据项既有段地址，也有偏移地址。然而，段地址是操作系统的财产，当做这种简单的用户空间编程时，我们可以放心地忽略它。回到 DOS 时代，我们则必须完成实用实模式分段内存模型，而且必须跟踪段寄存器；采用保护模式的方式完成它意味着少了一个令人头疼的问题(别担心，还有很多方法)



### 5.4.7 准备好要来真格的了吗

你已经具备了必要的基础。现在是时候拿出一些正式的工具，调查程序员对 Linux 操作系统的看法，并开始编写一些程序了。