# 第 7 章 跟踪指令 与机器指令亲密接触

它不是 PC 汇编语言的完整课程。一旦“跑到”了本书的最后，你就可以抬脚奔向各个出版社的众多其他汇编语言书籍了。



## 7.1 为自己建立一个沙盒

认识 x86 机器指令的最佳方法是建立一个自己的沙盒，并且玩得开心。沙盒中的汇编语言程序并不需要在 Linux 中正确地运行。它甚至不需要像一般程序员那样完整。所有它必须具有的特点就是能够被 NASM 和连接器理解。

按照我个人的技术术语来讲，沙盒就是一个打算在调试器中运行的程序。

我的沙盒思想是这样的：为一个名为 sandbox.asm创建一个用于编译和连接的生成文件(Makefile)。你可以创建一个代码量很小的 NASM 程序，并将其以文件名 newsandbox.asm 保存到磁盘上。什么时候想“摆弄”机器指令，你都可以打开 newsandbox.asm ，将其再次保存为sandbox.asm，覆盖所有可能存在的sandbox.asm 早期版本。你可以添加指令用于观察，并使用 Linux 的 Make 使用工具生成一个可执行文件。然后，调试该程序。



你的实验程序有可能产生一些具有保存价值的有用的机器指令组合。在这种情况下，你将沙盒文件另存为 experiment1.asm(或者任何你想赋予它的描述性名称)。一旦时机成熟，随时都可以从那个序列生成一个“真正的”程序。



### 7.1.1 一个最小的NASM 程序

```asm
section .data
section .text

    global _start


_start
    nop

    nop

section .bss
```


我们真正需要的是一个标记为全局(global)的起始点，这里为 _start 标号。我们还需要定义一个.data段和一个 .text 段。.data段用于保存已命名数据项，当程序运行时，它们将被赋予初始值。清单 5-1 中的"Eat at Joe's"信息就是数据段中的一个已命名数据项。.text 段用用于存放程序代码。要想创建一个可执行文件，这两个段都是必不可少的。



第二个标记 .bss 的段并不是必须的 ，但是，如果打算进行实验，拥有它会带来一些好处。.bss 段保存未初始化的数据，也就是说，该空间用于存放当程序运行时并没有接收任何初始值的数据项。从根本上讲，这些都是空的缓冲区，用于存放程序运行期间即将产生的数据，或者从某处读取数据。按照惯例，.bss 段位于 .text 段的后面

```makefile
andbox: sandbox.o
	ld -m elf_i386 -o sandbox sandbox.o

sandbox.o : sandbox.asm
	nasm -f elf -g -F DWARF sandbox.asm -l sandbox.1st
```

-l 的意思是：生成一个sandbox.1st 和一个 sandbox.o，这样这个版本就被保存下来了



使用gdb 调试，可以看到程序将不正常退出。

Linux 将提交一个分段错误，其中的原因可能有若干种。但是，本例中发生这种情况的原因是程序视图执行一个已经超过 .text 段结尾位置的代码。当程序被加载时，Linux 知道该程序有多长，它不允许执行任何在程序中不存在的指令。

当然，这并没有什么持久性的伤害，Linux 非常善于处理错误的行为和畸形的程序，没有什么意外事件会对 Linux 有所影响。



### 7.1.2 指令及其操作数

在汇编语言工作中，最常见的活动就是将数据从这里移到那里。有一种专门做这件事的方法，但真正通用的只有一个: MOV 指令。MOV 运行的操作：

* 可以从一个寄存器到另一个寄存器
* 从一个寄存器到一个内存地址或从一个内存地址到一个寄存器移动一个字节(8位)，一个字(16位)或者一个双字(32位)的数据。

不能做的事情是直接从一个内存地址移动另一个内存地址中。



### 7.1.3 源操作数和目标操作数

大多数机器指令(包括 MOV)有一个或多个操作数(有些指令没有操作数，或隐式地操作寄存器或存储器)。

如下机器指令：mov eax,1

上述机器指令有两个操作数:第一个是 EAX，第二个是数字1。

在汇编语言中，一条机器指令的第一个(最左边)操作数是目标操作数。从左边数第二个操作数是源操作数。

只要某些机器指令产生一个新值，这个新值就被放在目标操作数中。

有三种不同类型的数据可以作为操作数：

* 内存中的数据
* 寄存器中的数据
* 立即数



### 7.1.4 立即数

例如以下指令：`MOV EAX,42H`，42H是一个立即数，它通过名为立即数寻址的寻址模式来访问立即数。**立即数寻址的名字来源于这样的事实：被寻址的项刚好是内置在机器指令中的数据。**它不是存放在寄存器中，也不是存放在位于指令之外的某个内存中。立即数总是位于正被取出和执行的指令的内部。

从内存中获取任何数据的时间均超过从寄存器中获取任何数据的时间，毕竟，指令都存储在内存中。因此，对立即数的寻址的速度总是比对存储在内存中的普通数据寻址的速度快，但是，从这两个地方取出数据的速度，都不如从 CPU 寄存器中简单地取出一个数值的速度快。

**只有源操作数可以是立即数**



NASM 还允许一些有趣的立即数，例如: mov eax, ‘WXYZ’

在调试器中可以看到，EAX 的值是: 0x5a595857

根据 ASCII 恰好为: ZYXW

因为IA-32 架构的CPU是小端序，因此刚好和‘WXYZ’的对应值相反。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-11%20%E4%B8%8B%E5%8D%883.11.15.png" alt="截屏2021-06-11 下午3.11.15" style="zoom:67%;" />





### 7.1.5 寄存器数据

我们将存储在 CPU 内部的数据称为寄存器数据，将直接访问寄存器数据的内存寻址模式称为寄存器寻址。

```asm
mov ebp,esi       ; 32 位
mov bl,ch         ; 8位
add di,ax         ; 16位  将di和ax中的内容相加，并将结存存入 目的寄存器di中
add ecx,edx       ; 32位
```



**无论是什么指令，只要直接作用于寄存器中的数据，就会发生寄存器寻址。**

有一种特殊情况就是，在同一条指令中出现一个 16 位的半寄存器和一个完整的 32 位寄存器。这种操作是不合法的。将 2 个字节源操作数移动到一个 4 字节的目标操作数种似乎是可能的，甚至是合理的，但是 CPU 并不支持这种操作。



`xchg cl,ch` 用于交换两个寄存器的值

有时候，在机器执行时间方面，某种“特殊情况”要比一般情况更快一些。例如被 2 的幂数相处，我们可以使用 DIV 指令实现，但也可以通过 SHR(右移位)指令实现。DIV 是更为一般的办法（你可以用它来实现任何无符号整数除法，不仅仅是 2 的幂数）,但是它的速度非常缓慢，在某些种类的 x86 处理器上，甚至比 SHR 指令的速度慢高达 10 倍!



### 7.1.6 内存数据

内存数据是存储在分配给某个程序的系统内存中的某个 32 位内存地址处的数据。除了一两个例外(如字符串指令，本章后文会涉及，但并不进行详细讲解)之外，一条指令的两个操作数只有一个可以指定内存位置。

如果想要指定的数据是位于寄存器中的内存地址中的值，而不是寄存器本身中的数据，需要在寄存器名字的两边加上方括号。

例如，如果想将存放在寄存器 EBX 中的内存地址处的双字移到寄存器 EAX 中，应该使用以下指令：

`mov eax,[ebx]`



还可以在寄存器的括号内添加字面常量，NASM 会进行数学计算：

`mov eax,[ebx+16]`

也可以添加两个通用寄存器，就像这样：

`mov eax,[ebx+ecx]`

而且，如果还不够，可以添加两个寄存器，外加一个字面常量：

`mov eax,[ebx,ecx+11]`

当然，这还没包含全部的合法形式。括号中的所有内容称为内存数据项的有效地址(effective address)，并且有一些规则来规定哪些是合法的有效地址，哪些不是。在目前的 x86 硬件演变中，可以将两个寄存器加在一起，形成有效地址，但没有三个寄存器或更多的情况。换句话说，下面的指令是非法的：

`mov eax ,[ebx,ecx,edx]`  



### 7.1.7 混淆数据和它的地址

例如下面的指令

```asm
EatMsg db "Eat at Joy's"
mov ecx, EatMsg
```

该指令并不是把 EatMsg的值存入 ECX 中，而是将 EatMsg的地址存入 ECX 中。在汇编语言中，变量名代表的是地址，不是数据。

那么，实际上该如何到达一个由(想 EatMsg 一样的)变量表示的数据呢? 同样，这也可以通过使用方括号来实现：

`mov ecx,[EatMsg]`

这条指令所做的事情就是从 EatMsg 代表的内存地址中取出前 32 位数据，并从最低有效字节开始，将其加载到EDX 中。根据我们为 EatMsg 定义的内容，那将是 'E' 'A' 't' '  '四个字符。用 ASCII码表示。



### 7.1.8 内存数据的尺寸

如果只想要其中一个单独字符，而不是前 4 个字符，该怎么办？从根本上来讲，如果想使用一个字节的数据，需要将其加载到一个字节大小的容器中。例如：

```asm
 msg db "hello world"
 mov al,[msg]
 mov bl,[msg+1]
```

al保存 h的 ASCII ，bl保存 e的 ASCII。

将寄存器中的数据写到内容时，尺寸问题将变得棘手。NASM 并不像高级语言那样“记得”变量的大小。它只知道 msg 从内存中什么地方开始，就这么简单。你必须告诉 NASM 需要移动多少个字节的数据。这是通过大小说明符(size specifier)来实现的。例如:

mov [msg],byte 'G '

这里通过大小说明符byte告诉 NASM，你只想移出一个字节到内存中。其他的大小说明符包括WORD(16位)，DWORD(32位)。



### 7.1.9 糟糕的过去

很高兴你是在现在学习 x86 汇编，因为在前些年学习它要复杂得多。在 DOS 实模式下，对于一个有效地址的组成部分有几个限制，而这些限制在当今的 32 位保护模式下已经不复存在了。在实模式下，只有某些 x86 通用寄存器能够存放内存地址：BX, BP,SI 和 DI。而其他的寄存器AX，CX和DX则不能。



更糟糕的是，正如第四章描述的那样，必须确保通过使用类似[DS:BX]结构指定段地址。而且必须处理名为ASSUME 的恶魔般的事情，对此还是少说为妙。



在许多方面，我们的生活都变得越来越美好了。



## 7.2 CPU 的标志位

一个标志是一个单独的二进制信息位，它的含义独立于任何其他位。根据 CPU 的需要，一个二进制位可以被 CPU 设置为 1 或者清除为 0.这样做是为了告诉你(程序员)CPU 内部的某些条件的状态，以便程序员可以对其进行测试并根据那些条件的状态采取相应的行动。更少见的情况是，你(程序员)也可以设置一个标记，并将其作为一种向 CPU 发送某些信号的方式。

作为整体来看，EFlags 只是一个掩藏在 CPU 内部的 32 位寄存器。它是出现在 8086/8088 CPU 中的16位标志寄存器的 32 位扩展后代。其 32 位中的每一位都是一个标志。尽管这些标志很常见。此外，还有许多标记没有被因特尔定义，而且尚未使用或暂未使用。

<img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-06-11%20%E4%B8%8B%E5%8D%885.32.55.png" alt="截屏2021-06-11 下午5.32.55"  /> 



EFlags 寄存器中的每一个标志都有一个由两个或三个字母组成的符号，大多数程序员通过这些符号来了解它们。

* OF：溢出标志，当对一个有符号整数量的算术运算操作结果过于庞大，以至于不能适合原来的操作数时，溢出标志 OF 被设置。当"进位标志"被标记时，溢出标志通常也被设置。
* DF：方向标志，它告诉 CPU 某些你想让它知道的东西，而不是反过来(CPU 想让你知道)的其他方式。它决定了字符串指令执行过程中的行为移动方向(上内存或者下内存)。当 DF 被设置时，字符串指令从高内存向低内存进行。当 DF 被清除时，字符串指令从低内存向高内存进行。
* IF；中断使能标志是一个双向标志。CPU 在某些条件下设置它，你也可以使用STI 和 CLI 指令来自己设置它。当 IF 被设置时，中断被启用，并且当需要时可以发生。当 IF 被清除时，中断将被 CPU 忽略。早在 DOS 时代，普通程序就可以在实模式下自由地设置和清除这个标志。但在 Linux 下，IF 是供操作系统使用的，有时是为它的驱动程序所用。如果你尝试在自己的程序中使用 STI 和 CLI 指令之一，Linux 将会提交一个一般保护错误，并终止程序。一定要考虑 IF 的"军事禁区"。
* TF：当被设置时，单步标志允许调试器通过强制 CPU 在调用一个中断程序前只执行一条指令来实现单步管理。对于一般编程而言，这不是一个特别有用的标志，我也不会对其做更多的讲解。
* SF：当一个操作的结果强迫操作数变为负数时，符号标记被设置，“负”只是意味着在一次有符号运算中，操作数中排序最高的位(符号位)变成了1。任何结果为正的算术运算操作都会将 SF 清零。
* ZF：当一个操作的结果为零时，零标志被设置。反之，如果目标操作数变成某些非零值，则 ZF 被清零。该标志经常用于条件转移指令中。
* AF：辅助进位标志只用于 BCD 码算术运算。BCD 码算术将每个操作数的一个字节看作一对4位“半字节”，并通过使用 BCD 算术指令，允许一些近似十进制(基数为 10)的算术运算直接在 CPU 的硬件上完成。这些指令已经不再使用。
* PF：对于任何了解串行数据通信的人而言，奇偶标志看起来应该很熟悉，但是对于那些不熟悉的人们而言，则完全是件完全奇怪的事情。PF 表明某个结果数字的排序最低的字节中被设置为 1 的二进制位的个数是奇数还是偶数。例如，如果结果为 0F2H，那么 PF 将被清除，因为0F2H(11110010)中包含奇数个设置为 1 的二进制位。同样，如果结果是3AH(00111100)，那么PF 将被设置为1。该标志位是计算机串口通信遗留下来的。
* CF：进位标志用于无符号算术运算。如果一个算术或移位操作的结果从操作数“进”1位，CF被设置。否则，如果没有进位，CF 将被清除。



### 7.2.1 标志防范

请查看每一条指令的指令参考部分，看看它是否影响了标志。



### 7.2.2 使用 INC 指令和 DEC 指令加 1 和 减 1

有些 x86 机器指令是成对出现的。这些指令之中最简单的就是 INC 和 DEC，它们将一个操作数分别加1和减1。

如下述指令：

```asm
mov eax,0FFFFFFFFH
mov ebx,02DH
dec ebx
inc eax
```

调试上述指令，EBX 变为0CH，EAX 变为 0，因为EAX 的值加一产生了溢出，但此时**进位标志不受INC指令影响**



### 7.2.3 在调试程序中观察标志

dec 指令影响的标志位为: OF，SF，ZF，AF 和 PF 标志。DEC EBX 指令将所有这些标志清零，原因如下：

* 溢出标志(OF)被清除，因为被解释为有符号整数的操作数并没有变得太大，以至于无法存放在 EBX 中。
* 符号标志(SF)被清除，因为操作的结果没有使得 EBX 的最高位变成1。假如 EBX 的最高位变成1，那么，被解释为有符号整数的 EBX 
* 的值将成为负数，当一个变为负数时，SF 被设置。所以，像 OF 一样，SF也没有多大用处，除非正在做有符号算术运算。
* 零标志(ZF)被清零，因为目标操作数不等于零。如果为零，ZF 将被设置为 1。
* 辅助进位标志(AF)被清零，因为没有从 EBX的低四位向高四位的 BCD 码进位。
* 奇偶标志(PF)被清零，当目标操作数的二进制位 1 的数量是奇数时，PF 被清零。
* DEC指令不影响 IF 标志，它仍然被设置为 1.



现在执行 INC EAX 指令，并重新在调试器中查看。

* 奇偶标志(PF)被设置，因为 EAX 的值为 1 的二进制位的个数是零，当操作数的值为 1 的二进制位的个数是偶数时，PF 被设置为 1。0被认为是偶数。

* 辅助进位标志 AF 被设置低4位从 FFFF 变成了 0000。这意味着从低 4 位到高 4 位 有进位，当操作数的低 4 位有进位时，AF 被设置。
* 零标志(ZF) 被设置，因为 EAX 变成了零。
* 像前面一样，IF 标志没有变化，仍然一直处于设置状态。



### 7.2.4 标志如何改变程序的运行

```
section .data
    myname db "WANG"
section .text
    global _start

_start
    nop
    
        mov ebx,myname
        mov eax,4
    DoMore: add byte [ebx],32
        inc ebx
        dec eax
        jnz DoMore
    
    nop
section .bss
```



该程序将数据段中的变量myname中的每个字符，由大写变为小写。采用的方法是，将其 ASCII 码加上 32。

该程序将循环 4 次，每次改变一个字符。



## 7.3 有符号值和无符号值

在汇编语言中，既可以使用有符号数，也可以使用无符号的数。当然，有符号数可以为负数的值，而无符号的值则始终为正。 在 X86 指令集中，有一些用于四种基本算术运算的指令，这些指令既可以操作有符号值，也可以操作无符号值。（对于乘法和除法，有单独的指令分别用于有符号和无符号计算）。

理解有符号数和无符号数之间的关键是知道 CPU 将符号放在什么地方。它不是一个破折号符号，而是实际上代表这个数字的二进制模式下的一个位。一个有符号数的最高有效字节的最高位是符号位。如果符号位的值为 1，则这个数为负数。如果符号位的值为0，则这个数为正数。

记住，一个给定的二进制模式到底代表一个有符号数还是无符号数，取决于你如何使用它。



### 7.3.1 补码 和 NEG

CPU 在逻辑层面上，并不真正需要减法。它只是产生减数的补码，并将其与被减数相加。

使用机器指令 NEG 可以求一个数的补码，并取负。**当对一个数执行NEG时会假定该数作为负数处理，因为会将该数的符号为置为1**

一个有符号数，最高位为符号为，1代表负数，0代表正数

有符号数的范围为

![截屏2021-06-14 下午4.43.52](https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/number.png)



将 8 位最大正数值(7FH)加1，将得到一个最大的负值(80H)

在 GDB 中可以以 十六进制，十进制和无符号数之间进行选择。这三种格式采用如下方式工作：

* 十六进制以十六进制显示该值。
* 十进制形式将该值表示为一个有符号数，最高位当成符号位来处理。
* 无符号形式将该值表示为一个无符号值，把最高位只是看成整个数中的一个二进制位。



### 7.3.2 符号扩展和 MOVSX

GDB 不能显示低于 32 位的有符号值，低于 32 位，符号为会被看成是数值位。

默认情况下，如果我们执行`mov ax,-42`，ax会被显示为 65494，使用普通的 mov 指令执行 `mov ebx,eax`

那么ebx也只是显示65494，它并不会显示为一个负数。

为了克服这个缺陷，我们应该使用 MOVSX 指令，MOVSX 的意思是“带符号扩展一起移动”

```asm
mov ax,-42
movsx ebx,ax 
```

执行完上述指令，ebx，将会以 10 进制显示 -42



MOVSX 指令

| 机器指令 | 目标操作数 | 源操作数 | 操作说明                     |
| -------- | ---------- | -------- | ---------------------------- |
| MOVSX    | r16        | r/m8     | 8 位有符号数到 16 位有符号数 |
| MOVSX    | r32        | r/m8     | 8 位有符号数到 32 位有符号数 |
| MOVSX    | r32        | r/m16    | 16位有符号数到 32 位有符号数 |

**目标操作数只能有一个寄存器**，r/m 的意思是任意的寄存器或者内存位置，后面跟它们的位数

例如：r/m16 指任意的 16 位寄存器或内存位置。



## 7.4 隐式操作数

有些指令实际上也有操作数，但是这些操作数代表的是由指令做出的假设。这种操作数被称为隐式操作数，它们永远不变，也不能被更改。使情况变得更复杂的是，大部分包含隐式操作数的指令同时也包含显示操作数。

在 x86 指令集中，最好的隐式操作的例子是乘法和除法指令。排除专门的数学处理器(x86，MMX 和 SSE)中的指令，x86 指令集有两套乘法和除法指令。**一组是 MUL 和 DIV，用于处理无符号计算。** **另一组是IMUL和IDIV，用于处理有符号计算。**

MUL 指令完成我们期望它做的事情：它将两个值相乘，然后返回一个结果。然而，在基本的数学运算中，乘法有一个特殊的问题：它产生的输出值经常比输入值大很多。这使得我们无法按照 x86 指令模式操作，即把指令产生的结果存入目标操作数中。

考虑一个 32 位乘法操作。32 位寄存器中能够存放的最大无符号值是 294967295。它们即使是与 2 相乘也会得到一个 33 位的结果，而该结果不再适合任何 32 位寄存器。当 x86 是 16 位体系结构使，就存在着将两个 16 位值的，非常容易溢出 16 位寄存器的计算结果存放到何处的问题。

为了解决这个问题，Intel 的设计师们采用它们唯一能够做到的方法：使用两个寄存器来保存结果。

两个二进制数的最大乘机的位数不超过较大因子的位数的两倍。简单地说，任意两个 16 位值的乘积都适合存储在 32 位容器中，而任意两个 32 位值的乘积都适合存储在 64 位容器中。



观察下述指令`mul ebx`

该指令将计算机 EBX * EAX，并将结果保存在 EDX 和 EAX 中，EBX 作为显式操作数，EAX 作为隐式操作数，EDX 和 EAX作为隐式操作数(结果)。这带来 3 种变体。

| 机器指令 | 显式操作数(因子1) | 隐式操作数(因子2) | 隐式操作数(结果) |
| -------- | ----------------- | ----------------- | ---------------- |
| mul      | r/m8              | AL                | AX               |
| mul      | r/m16             | AX                | DX and AX        |
| mul      | r/m32             | EAX               | EDX and EAX      |

第一个因子以一个明确的操作数给出，它可以是一个寄存器中的值，也可以是某个内存位置中的值。第二个因子是隐式的，并且总是在适合于第一个因子位数的 "A" 系列通用寄存器中。如果第一个因子是一个 8 位值，第二个因子总是在 8 位寄存器 AL 中。如果第一个因子是一个 16 位值，第二个因子总是在 16 位寄存器 AX 中，依次类推。

一旦结果需要不止 16 位，“D”系列寄存器就被“征用”，以存放计算结果的高序位部分。这里的“高序位”指的是不适合在 “A” 系列寄存器中存放的那部分计算结果。**例如将两个 16 位值相乘，得到的结果是02A456FH，那么，寄存器 AX 中会包含 0456FH，而 DX 寄存器中则存放 02AH。**

即使计算结果足够小，以至于存放结果的两个寄存器之一就能够存放它，高位寄存器(不论是AH，DX，或EDX)仍然被清零。

MUL 指令的操作数不能为立即数；也就是说，你不能做以下事情，将第一个因子声明为立即数：

`mul 42`



### 7.4.1 MUL 和进位标志

MUL 产生的结果如果很大，将由两个寄存器来保存结果，用 EDX 保存高位部分，用 EAX 保存低位部分。可以通过进位标志 CF，看是否有高位部分。



### 7.4.2 使用 DIV 实现无符号除法

被除数是隐式操作数，存放在 EDX(高位部分) 和 EAX(低位部分) 中，除数存放在 DIV 的唯一显式操作数中，它可能在寄存器中 或者内存中(同乘法指令一样，不能使用立即数作为操作数)。返回的商数存放在 EAX 中，余数存放在 EDX 中。

如同乘法指令一样，DIV 的隐式操作数取决于显示操作数的尺寸。

| 机器指令 | 显式操作数(除数) | 隐式操作数(商的整数部分) | 隐式操作数(商的余数部分) |
| -------- | ---------------- | ------------------------ | ------------------------ |
| DIV      | r/m8             | AL                       | AH                       |
| DIV      | r/m16            | AX                       | DX                       |
| DIV      | r/m32            | EAX                      | EDX                      |

无论是除数还是被除数，都不能为零。



### 7.4.3 x86 中的“慢动作” 指令

DIV 和 MUL 指令接近整个 x86 指令集中最慢的的指令。两条指令的 32 位版本均慢于 16 位版，8位版本是所有版本中最快的。

在最新的奔腾级 CPU 指令中，其他因素开始发挥作用，这使得泛泛地谈论指令速度几乎成为不可能的事情，当然更不可能对其进行精确地说明了。

在那些不断执行大量计算的循环中，比如图形绘制和视频处理(如果正在做此类事情，你也许应该使用 x86 体系结构的数学处理器部分，而不是 MUL 指令和 DIV 指令)，指令速度至关重要。我的个人启发是使用输入值运行的最小版本的 MUL 和 DIV 指令，而且大多数时候被更大的启发所冲淡，指令速度并不重要。当汇编语言经验足够丰富，以至于能够进行指令级性能决策时，你将知道这一点。在此之前，你应该集中精力在程序错误上，而将速度问题仍给 CPU。



## 7.5 阅读和使用汇编语言参考资料

在手头预留一些其他类型的参考文档，以唤醒他们对于机器指令细节的记忆。



### 7.5.1 对于复杂记忆的唤醒文件

Intel 的处理器文档：https://software.intel.com/content/www/cn/zh/develop/articles/intel-sdm.html

Borland 的 Turbo Assembler 快速参考指南，关于汇编指令的材料并不适用于 NASM，但是它的指令参考包括能够在 486 上通过的所有 32 位形式的指令，而这是一个汇编初学者可能使用的几乎所有内容。



### 7.5.2 初学者汇编语言参考指南

现代 x86 中的很多复杂指令和内存寻址机制只为操作系统和驱动程序使用。对于短小的运行在用户模式下的应用，它们根本不适用。

初学者经常参考的，最常见的 x86 指令在附录 A 中。对于在本书中的每一条指令，附录 A 中都至少包含一页的内容，加上一些其他的，每个人都应该知道的指令。它并不包括每一条指令的描述，而是只对那些最常见和最有用的进行描述。一旦你已经足够熟练，可以使用那些更为神秘的指令时，你应该能够阅读英特尔的 x86 文档，并且将其运用在汇编工作中。



### 7.5.3 标志

在附录 A 中，所有受指令影响的标志的符号下方都将有一个星号(*)出现。标志是如何受到影响的，取决于指令所做的事情。



### 7.6 NEG：求补(求补码；即，与-1相乘)

一个值的补码与该值相加，产生的结果为零。

如果操作数为 0 ，则 CF 被清零，ZF 被设置，否则，CF 被设置，ZF 被清零。

如果操作数包含最大值(8 位最大值 -128; 16 位最大负值为 -32768)，则操作数不变，但是OF，CF 被设置。如果结果为 负，则 SF 被设置，否则 SF 被清除。如果结果的低 8 位包含偶数个 1 的位，PF 被设置，否则 PF 被清零。



### 7.6.1 合法形式

实际上不同的形式代表不同的二进制操作码。例如，在最底层，POP AX 指令的二进制数 058H，而 POP SI 指令是二进制数 05EH。多数操作码不是单个的 8 位值，大多数至少有两个字节长，而且往往是4个或更多个字节。

当你想使用具有一组特定操作数的指令时，务必检查该指令饿参考指南中的“合法形式”小节，以确保该组是合法的。与以前的糟糕的 DOS 时代比，现在有更多的合法形式，很多保留下来的限制都涉及段寄存器，当编写一般的 32 位保护模式用户应用程序时，你将无法使用它。例如，MOV 指令不能将数据从某个内存位置移动到另一个内存位置，并且在实模式下存在一些如何在段寄存器中存放数据的限制。



### 7.6.2 操作数符号

r8：一个 8 位的半寄存器，AH，AL，BH，BL，CH，CL，DH或者DL

r16：一个 16 位通用寄存器，AX，BX，CX，DX，BP，SP，SI或者DI

r32：一个 32 位通用寄存器，EAX，EBX，ECX，EDX，EBP，ESP，ESI或者EDI

sr：一个段寄存器，CS，DS，SS，ES，FS或者GS

m8：一个 8 位的字节内存数据

m16：一个 16 位的内存数据

m32：一个 32 位的内存数据

i8：一个 8 位的字节内存立即数

i16：一个 16 位的字立即数

i32：一个 32 位的双字立即数

d8：一个 8 位的有符号位移

d16：一个 16 位的有符号位移，用于 jump指令和call指令

d32：一个 32位的有符号位移



### 7.6.3 示例

我试图为每一条指令提供一个良好的范例取样，尽量体现该条指令不同可能性的范畴。



### 7.6.4 注解

附录 A 中，“注释”小节简单描述了指令的活动，并提供了一些信息，包括它如何影响标志，如何可能被限制使用，以及所有需要记住的其他细节，特别是那些初学者容易忽视或误解的内容。



### 7.6.5 这里没有包含的内容

附录A 中不同于大多数详尽的汇编语言参考资料，它不包括操作码的二进制编码信息，也没有表明该指令的每种形式使用多少机器周期的相关内容。

一条指令的二进制编码是 CPU 消化和识别的机器指令的实际二进制字节序列。我们称之为 POP AX 的指令被机器视为二进制数 58H。我们称之为 ADD SI,07733H的机器指令视为 4 个字节的序列: 81H 0C6H 33H 77H。机器指令可以被编码到任意地方，根据它们是什么指令以及操作数是什么，从一个到四个(有时更多)二进制字节不等。

像 Michael Abrash 在他的巨著 《Michael Abrash 的图形编程黑皮书》中这样说，要想知道一个给定系列的指令将花费多长时间来执行，仅仅知道单个指令的执行周期还远远不够，即使是专家级别的汇编语言编程员。 CPU 缓存，预取指，分支预测，超线程和任意数量的其他因素结合在一起，相互作用，使得进行这样的计算几乎是不可能的，除非从广义上来讲。

